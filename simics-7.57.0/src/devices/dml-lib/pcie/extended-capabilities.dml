/*
  Â© 2021 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

dml 1.4;

/**
   These are templates for PCIe Extended Capabilities. They are designed to be
   applied on a `group`. For convenience there exists a template
   `defining_xyz_capability` for each capability `xyz` which defines a group
   `xyz` with the `xyz_capability` applied.  Most templates only define the
   registers with their standard access restrictions.  If additional behavior is
   needed, the user of the template must implement this manually.

   Each extended capability template uses the following parameters:
   * `base`: Base address of the capability header
   * `next_ptr`: Value of the next_ptr field in the capability header
*/

template extended_capability is (group) {
    param base;
    param id;
    param next_ptr;
    param version default 1;
    param use_standard_access_templates
        default bank.use_standard_access_templates;
    param use_standard_write_templates
        default bank.use_standard_write_templates;

    shared method get_base() -> (uint64);
    method get_base() -> (uint64) default {
        return base;
    }

    register capability_header size 4  @ base is pcie_desc {
        param pcie_desc = "Capability Header";
        field id       @ [15:0]  is pcie_desc {
            param pcie_desc = "Capability ID";
            param init_val default parent.parent.id;
        }
        field version  @ [19:16] is pcie_desc {
            param pcie_desc = "Capability Version";
            param init_val default parent.parent.version;
        }
        field next_ptr @ [31:20] is pcie_desc {
            param pcie_desc = "Next Capability Offset";
            param init_val default parent.parent.next_ptr;
        }
    }

#if (use_standard_access_templates) {
    register capability_header is read_only;
}
}

/**
   ## Advanced Error Reporting (AER) Capability registers

    - name: `aer_capability`
    - implemented: registers only

    Uses the following parameters:
    * `tlp_prefix_log_or_header_log_ctd_len`: The length in DWs of the TLP
      Prefix Log or Header Log (continued, for Flit mode) register, default 4
*/
template aer_capability is extended_capability {
    param id = 1;
    param version default pcie_version > 1 #? 2 #: 1;
    param tlp_prefix_log_or_header_log_ctd_len default 4;

    #if (tlp_prefix_log_or_header_log_ctd_len > 10) {
        error "tlp_prefix_log_or_header_log_ctd_len must be <= 10";
    }

    register unc_error_status   size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "Uncorrectable Error Status";
    }
    register unc_error_mask     size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "Uncorrectable Error Mask";
    }
    register unc_error_severity size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "Uncorrectable Error Severity";
    }
    register corr_error_status  size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "Correctable Error Status";
    }
    register corr_error_mask    size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "Correctable Error Mask";
    }
    register cap_control        size 4 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "Advanced Error Capabilities and Control";
    }
    register header_log_1       size 4 @ (base + 0x1c) is pcie_desc {
        param pcie_desc = "Header Log (1st DW)";
    }
    register header_log_2       size 4 @ (base + 0x20) is pcie_desc {
        param pcie_desc = "Header Log (2nd DW)";
    }
    register header_log_3       size 4 @ (base + 0x24) is pcie_desc {
        param pcie_desc = "Header Log (3rd DW)";
    }
    register header_log_4       size 4 @ (base + 0x28) is pcie_desc {
        param pcie_desc = "Header Log (4th DW)";
    }
    register root_error_cmd     size 4 @ (base + 0x2c) is pcie_desc {
        param pcie_desc = "Root Error Command";
    }
    register root_error_status  size 4 @ (base + 0x30) is pcie_desc {
        param pcie_desc = "Root Error Status";
    }
    register error_source_id    size 4 @ (base + 0x34) is pcie_desc {
        param pcie_desc = "Error Source Identification";
    }
    #if (tlp_prefix_log_or_header_log_ctd_len > 0) {
        register tlp_prefix_log_or_header_log_ctd[i < tlp_prefix_log_or_header_log_ctd_len]
            size 4 @ (base + 0x38 + i * 4) is pcie_desc {
            param pcie_desc = "TLP Prefix Log or Header Log DW5-14";
        }
        register tlp_prefix_log[i < tlp_prefix_log_or_header_log_ctd_len] size 4
            is (unmapped, pcie_desc, set, get, read, write) {
            param configuration = "pseudo";
            param pcie_desc = "TLP Prefix Log";

            method set(uint64 value) {
                tlp_prefix_log_or_header_log_ctd[i].set(value);
            }
            method get() -> (uint64) {
                return tlp_prefix_log_or_header_log_ctd[i].get();
            }
        }
    }
    register header_log[i < tlp_prefix_log_or_header_log_ctd_len + 4] size 4
        is (unmapped, pcie_desc, set, get, read, write) {
        param configuration = "pseudo";
        param pcie_desc = "Header Log";

        method set(uint64 value) {
            switch (i) {
                case 0:
                    header_log_1.set(value);
                    break;
                case 1:
                    header_log_2.set(value);
                    break;
                case 2:
                    header_log_3.set(value);
                    break;
                case 3:
                    header_log_4.set(value);
                    break;
                default:
                    // assert can be removed after switching to Simics API 8
                    // where no_method_index_asserts is disabled
                    assert tlp_prefix_log_or_header_log_ctd_len > 0;

                    // needed because tlp_prefix_log_or_header_log_ctd only
                    // exists if it has a positive length
                    #if (tlp_prefix_log_or_header_log_ctd_len > 0) {
                        tlp_prefix_log_or_header_log_ctd[i - 4].set(value);
                    }
                    break;
            }
        }
        method get() -> (uint64) {
            switch (i) {
                case 0:
                    return header_log_1.get();
                case 1:
                    return header_log_2.get();
                case 2:
                    return header_log_3.get();
                case 3:
                    return header_log_4.get();
                default:
                    // assert can be removed after switching to Simics API 8
                    // where no_method_index_asserts is disabled
                    assert tlp_prefix_log_or_header_log_ctd_len > 0;

                    // needed because tlp_prefix_log_or_header_log_ctd only
                    // exists if it has a positive length
                    #if (tlp_prefix_log_or_header_log_ctd_len > 0) {
                        return tlp_prefix_log_or_header_log_ctd[i - 4].get();
                    }
            }
        }
    }

    register unc_error_status {
        field dlpes  @ [4:4]   is pcie_desc {
            param pcie_desc = "Data Link Protocol Error Status";
        }
        field ptlps  @ [12:12] is pcie_desc {
            param pcie_desc = "Poisoned TLP Status";
        }
        field fcpes  @ [13:13] is pcie_desc {
            param pcie_desc = "Flow Control Protocol Error Status";
        }
        field cts    @ [14:14] is pcie_desc {
            param pcie_desc = "Completion Time-out Status";
        }
        field cas    @ [15:15] is pcie_desc {
            param pcie_desc = "Completer Abort Status";
        }
        field ucs    @ [16:16] is pcie_desc {
            param pcie_desc = "Unexpected Completion Status";
        }
        field ros    @ [17:17] is pcie_desc {
            param pcie_desc = "Receiver Overflow Status";
        }
        field mtlps  @ [18:18] is pcie_desc {
            param pcie_desc = "Malformed TLP Status";
        }
        field ees    @ [19:19] is pcie_desc {
            param pcie_desc = "ECRC Error Status";
        }
        field ures   @ [20:20] is pcie_desc {
            param pcie_desc = "Unsupported Request Error Status";
        }
    }
    register unc_error_mask {
        field dlpem  @ [4:4]   is pcie_desc {
            param pcie_desc = "Data Link Protocol Error Mask";
        }
        field ptlpm  @ [12:12] is pcie_desc {
            param pcie_desc = "Poisoned TLP Mask";
        }
        field fcpem  @ [13:13] is pcie_desc {
            param pcie_desc = "Flow Control Protocol Error Mask";
        }
        field ctm    @ [14:14] is pcie_desc {
            param pcie_desc = "Completion Time-out Mask";
        }
        field cam    @ [15:15] is pcie_desc {
            param pcie_desc = "Completer Abort Mask";
        }
        field ucm    @ [16:16] is pcie_desc {
            param pcie_desc = "Unexpected Completion Mask";
        }
        field rom    @ [17:17] is pcie_desc {
            param pcie_desc = "Receiver Overflow Mask";
        }
        field mtlpm  @ [18:18] is pcie_desc {
            param pcie_desc = "Malformed TLP Mask";
        }
        field eem    @ [19:19] is pcie_desc {
            param pcie_desc = "ECRC Error Mask";
        }
        field urem   @ [20:20] is pcie_desc {
            param pcie_desc = "Unsupported Request Error Mask";
        }
    }
    register unc_error_severity {
        field dlpes  @ [4:4]   is pcie_desc {
            param pcie_desc = "Data Link Protocol Error Severity";
            param init_val default 0x1;
        }
        field ptlps  @ [12:12] is pcie_desc {
            param pcie_desc = "Poisoned TLP Severity";
        }
        field fcpes  @ [13:13] is pcie_desc {
            param pcie_desc = "Flow Control Protocol Error Severity";
            param init_val default 0x1;
        }
        field cts    @ [14:14] is pcie_desc {
            param pcie_desc = "Completion Time-out Severity";
        }
        field cas    @ [15:15] is pcie_desc {
            param pcie_desc = "Completer Abort Severity";
        }
        field ucs    @ [16:16] is pcie_desc {
            param pcie_desc = "Unexpected Completion Severity";
        }
        field ros    @ [17:17] is pcie_desc {
            param pcie_desc = "Receiver Overflow Severity";
            param init_val default 0x1;
        }
        field mtlps  @ [18:18] is pcie_desc {
            param pcie_desc = "Malformed TLP Severity";
            param init_val default 0x1;
        }
        field ees    @ [19:19] is pcie_desc {
            param pcie_desc = "ECRC Error Severity";
        }
        field ures   @ [20:20] is pcie_desc {
            param pcie_desc = "Unsupported Request Error Severity";
        }
    }
    register corr_error_status {
        field res     @ [0:0]   is pcie_desc {
            param pcie_desc = "Receiver Error Status";
        }
        field btlps   @ [6:6]   is pcie_desc {
            param pcie_desc = "Bad TLP Status";
        }
        field bdllps  @ [7:7]   is pcie_desc {
            param pcie_desc = "Bad DLLP Status";
        }
        field rnrs    @ [8:8]   is pcie_desc {
            param pcie_desc = "REPLAY_NUM Rollover Status";
        }
        field rtts    @ [12:12] is pcie_desc {
            param pcie_desc = "Replay Timer Timeout Status";
        }
    }
    register corr_error_mask {
        field rem     @ [0:0]   is pcie_desc {
            param pcie_desc = "Receiver Error Mask";
        }
        field btlpm   @ [6:6]   is pcie_desc {
            param pcie_desc = "Bad TLP Mask";
        }
        field bdllpm  @ [7:7]   is pcie_desc {
            param pcie_desc = "Bad DLLP Mask";
        }
        field rnrm    @ [8:8]   is pcie_desc {
            param pcie_desc = "REPLAY_NUM Rollover Mask";
        }
        field rttm    @ [12:12] is pcie_desc {
            param pcie_desc = "Replay Timer Timeout Mask";
        }
    }
    register cap_control {
        field fep     @ [4:0] is pcie_desc {
            param pcie_desc = "First Error Pointer";
        }
        field ecrcgc  @ [5:5] is pcie_desc {
            param pcie_desc = "ECRC Generation Capable";
        }
        field ecrcge  @ [6:6] is pcie_desc {
            param pcie_desc = "ECRC Generation Enable";
        }
        field ecrccc  @ [7:7] is pcie_desc {
            param pcie_desc = "ECRC Check Capable";
        }
        field ecrcce  @ [8:8] is pcie_desc {
            param pcie_desc = "ECRC Check Enable";
        }
    }
    register root_error_cmd {
        field cere   @ [0:0] is pcie_desc {
            param pcie_desc = "Correctable Error Reporting Enable";
        }
        field nfere  @ [1:1] is pcie_desc {
            param pcie_desc = "Non-Fatal Error Reporting Enable";
        }
        field fere   @ [2:2] is pcie_desc {
            param pcie_desc = "Fatal Error Reporting Enable";
        }
    }
    register root_error_status {
        field ecr    @ [0:0]   is pcie_desc {
            param pcie_desc = "ERR_COR Received";
        }
        field mecr   @ [1:1]   is pcie_desc {
            param pcie_desc = "Multiple ERR_COR Received";
        }
        field efnr   @ [2:2]   is pcie_desc {
            param pcie_desc = "ERR_FATAL/NONFATAL Received";
        }
        field mefnr  @ [3:3]   is pcie_desc {
            param pcie_desc = "Multiple ERR_FATAL/NONFATAL Received";
        }
        field fuf    @ [4:4]   is pcie_desc {
            param pcie_desc = "First Uncorrectable Fatal";
        }
        field nfemr  @ [5:5]   is pcie_desc {
            param pcie_desc = "Non-Fatal Error Messages Received";
        }
        field femr   @ [6:6]   is pcie_desc {
            param pcie_desc = "Fatal Error Messages Received";
        }
        field aeimn  @ [31:27] is pcie_desc {
            param pcie_desc = "Advanced Error Interrupt Message Number";
        }
    }
    register error_source_id {
        field ecsi  @ [15:0]  is pcie_desc {
            param pcie_desc = "ERR_COR Source Identification";
        }
        field efsi  @ [31:16] is pcie_desc {
            param pcie_desc = "ERR_FATAL/NONFATAL Source Identification";
        }
    }

#if (pcie_version == 1.0) {
    register unc_error_status {
        field tes    @ [0:0] is pcie_desc {
            param pcie_desc = "Training Error Status";
        }
    }
    register unc_error_mask {
        field tem    @ [0:0]   is pcie_desc {
            param pcie_desc = "Training Error Mask";
        }
    }
    register unc_error_severity {
        field tes    @ [0:0]   is pcie_desc {
            param pcie_desc = "Training Error Severity";
        }
    }
}

#if (pcie_version >= 2.0) {
    register unc_error_status {
        field sdes   @ [5:5]   is pcie_desc {
            param pcie_desc = "Surprise Down Error Status";
        }
        field acsvs  @ [21:21] is pcie_desc {
            param pcie_desc = "ACS Violation Status";
        }
    }
    register unc_error_mask {
        field sdes   @ [5:5]   is pcie_desc {
            param pcie_desc = "Surprise Down Error Mask";
        }
        field acsvm  @ [21:21] is pcie_desc {
            param pcie_desc = "ACS Violation Mask";
        }
    }
    register unc_error_severity {
        field sdes   @ [5:5]   is pcie_desc {
            param pcie_desc = "Surprise Down Error Severity";
            param init_val default 0x1;
        }
        field acsvs  @ [21:21] is pcie_desc {
            param pcie_desc = "ACS Violation Severity";
        }
    }
    register corr_error_status {
        field anfes  @ [13:13] is pcie_desc {
            param pcie_desc = "Advisory Non-Fatal Error Status";
        }
    }
    register corr_error_mask {
        field anfem  @ [13:13] is pcie_desc {
            param pcie_desc = "Advisory Non-Fatal Error Mask";
            param init_val default 1;
        }
    }
    register cap_control {
        field mhrc  @ [9:9]   is pcie_desc {
            param pcie_desc = "Multiple Header Recording Capable";
        }
        field mhre  @ [10:10] is pcie_desc {
            param pcie_desc = "Multiple Header Recording Enable";
        }
        field tplp  @ [11:11] is pcie_desc {
            param pcie_desc = "TLP Prefix Log Present";
        }
    }
}

#if (pcie_version >= 2.1) {
    register unc_error_status {
        field uies   @ [22:22] is pcie_desc {
            param pcie_desc = "Uncorrectable Internal Error Status";
        }
        field mbts   @ [23:23] is pcie_desc {
            param pcie_desc = "MC Blocked TLP Status";
        }
        field aoebs  @ [24:24] is pcie_desc {
            param pcie_desc = "AtomicOp Egress Blocked Status";
        }
        field tpbes  @ [25:25] is pcie_desc {
            param pcie_desc = "TLP Prefix Blocked Error Status";
        }
    }
    register unc_error_mask {
        field uiem   @ [22:22] is pcie_desc {
            param pcie_desc = "Uncorrectable Internal Error Mask";
        }
        field mbtm   @ [23:23] is pcie_desc {
            param pcie_desc = "MC Blocked TLP Mask";
        }
        field aoebm  @ [24:24] is pcie_desc {
            param pcie_desc = "AtomicOp Egress Blocked Mask";
        }
        field tpbem  @ [25:25] is pcie_desc {
            param pcie_desc = "TLP Prefix Blocked Error Mask";
        }
    }
    register unc_error_severity {
        field uies   @ [22:22] is pcie_desc {
            param pcie_desc = "Uncorrectable Internal Error Severity";
        }
        field mbts   @ [23:23] is pcie_desc {
            param pcie_desc = "MC Blocked TLP Severity";
        }
        field aoebs  @ [24:24] is pcie_desc {
            param pcie_desc = "AtomicOp Egress Blocked Severity";
        }
        field tpbes  @ [25:25] is pcie_desc {
            param pcie_desc = "TLP Prefix Blocked Error Severity";
        }
    }
    register corr_error_status {
        field cies   @ [14:14] is pcie_desc {
            param pcie_desc = "Corrected Internal Error Status";
        }
        field hlos   @ [15:15] is pcie_desc {
            param pcie_desc = "Header Log Overflow Status";
        }
    }
    register corr_error_mask {
        field ciem   @ [14:14] is pcie_desc {
            param pcie_desc = "Corrected Internal Error Mask";
        }
        field hlom   @ [15:15] is pcie_desc {
            param pcie_desc = "Header Log Overflow Mask";
        }
    }
}
#if (pcie_version >= 5.0) {
    register cap_control {
        field ctphlp  @ [12:12]   is pcie_desc {
            param pcie_desc = "Completion Timeout Prefix/Header Log Capable";
        }
    }
}
#if (pcie_version >= 6.0) {
    register cap_control {
        field hls   @ [17:13] is pcie_desc {
            param pcie_desc = "Header log size";
        }
        field ltpfm @ [18]    is pcie_desc {
            param pcie_desc = "Log TLP was Flit Mode";
        }
        field ltps  @ [23:19] is pcie_desc {
            param pcie_desc = "Logged TLP Size";
        }
    }
}

#if (use_standard_access_templates) {
    register cap_control {
        field fep    is ignore_write;
        field ecrcgc is ignore_write;
        field ecrccc is ignore_write;
#if (pcie_version >= 2.0) {
        field mhrc   is ignore_write;
        field tplp   is ignore_write;
}
#if (pcie_version >= 6.0) {
        field hls   is (read_only);
        field ltpfm is (read_only);
        field ltps  is (read_only);
}
    }
    register header_log_1       is (read_only);
    register header_log_2       is (read_only);
    register header_log_3       is (read_only);
    register header_log_4       is (read_only);
    register error_source_id    is (read_only);
#if (tlp_prefix_log_or_header_log_ctd_len > 0) {
    register tlp_prefix_log_or_header_log_ctd[i < ...] is (read_only);
}
}
#if (use_standard_write_templates) {
    register unc_error_status   is (pcie_sticky, pcie_write_1_clears);
    register unc_error_mask     is (pcie_sticky);
    register unc_error_severity is (pcie_sticky);
    register corr_error_status  is (pcie_sticky, pcie_write_1_clears);
    register corr_error_mask    is (pcie_sticky);
    register cap_control        is (pcie_sticky);
    register header_log_1       is (pcie_sticky);
    register header_log_2       is (pcie_sticky);
    register header_log_3       is (pcie_sticky);
    register header_log_4       is (pcie_sticky);
    register root_error_status  is (pcie_sticky, pcie_write_1_clears);
    register error_source_id    is (pcie_sticky);
#if (tlp_prefix_log_or_header_log_ctd_len > 0) {
    register tlp_prefix_log_or_header_log_ctd[i < ...] is (pcie_sticky);
}
#if (pcie_version >= 5.0) {
    register cap_control {
        field ctphlp is (hwinit);
    }
}
}
}

template defining_aer_capability {
    param aer_offset;
    param aer_next_ptr;
    group aer is (aer_capability) {
        param base = aer_offset;
        param next_ptr = aer_next_ptr;
    }
}

/**
   ## Virtual Channel (VC) Capability registers

    - name: `vc_capability`
    - implemented: registers only
*/
template vc_capability is extended_capability {
    param id;  // mfvc: 8, vc: 9 if mfvc present, 2 otherwise
    param num_vcs;
    param vat_capability;
    param pat_entry_size;
    param pat_capability;

    param vat_offset default vat_capability > 0 #? 0x10 + num_vcs * 0xc #: 0;
    param pat_offset default pat_capability > 0 #? vat_offset + num_vcs * 0x10 #: 0;

    param is_mfvc = id == 8;
    param portfun = is_mfvc #? "Function" #: "Port";
    param pf = is_mfvc #? "f" #: "p";

    register port_capability1 size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Port VC Capability 1";
    }
    register port_capability2 size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Port VC Capability 2";
    }
    register port_control     size 2 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "Port VC Control";
    }
    register port_status      size 2 @ (base + 0xe) is pcie_desc {
        param pcie_desc = "Port VC Status";
    }
    group resource[i < num_vcs] {
        register capability size 4 @ (base + 0x10 + i * 0xc) is pcie_desc {
            param pcie_desc = "VC Resource Capability";
        }
        register control    size 4 @ (base + 0x14 + i * 0xc) is pcie_desc {
            param pcie_desc = "VC Resource Control";
        }
        register status     size 2 @ (base + 0x1a + i * 0xc) is pcie_desc {
            param pcie_desc = "VC Resource Status";
        }
    }

    group arbitration_table[i < num_vcs] {
#if (vat_offset > 0) {
        register vc[j < 16] size 1
            @ (base + vat_offset + i * 0x10 + j) is pcie_desc {
            param pcie_desc = "VC Arbitration Table";
        }
}
#if (pat_offset > 0) {
        register port[j < 16] size 1
            @ (base + pat_offset + i * 0x10 + j) is pcie_desc {
            param pcie_desc default "Port Arbitration Table";
        }
}
    }

    register port_capability1 {
        field evcc    @ [2:0]   is pcie_desc {
            param pcie_desc = "Extended VC Count";
            param init_val default num_vcs - 1;
        }
        field lpevcc  @ [6:4]   is pcie_desc {
            param pcie_desc = "Low Priority Extended VC Count";
        }
        field rc      @ [9:8]   is pcie_desc {
            param pcie_desc = "Reference Clock";
        }
        field pates   @ [11:10] is pcie_desc {
            param pcie_desc default "Port Arbitration Table Entry Size";
            param init_val default pat_entry_size;
        }
    }
    register port_capability2 {
        field vcac   @ [7:0]   is pcie_desc {
            param pcie_desc = "VC Arbitration Capability";
            param init_val default vat_capability;
        }
        field vcato  @ [31:24] is pcie_desc {
            param pcie_desc = "VC Arbitration Table Offset";
            param init_val default vat_offset / 0x10;
        }
    }
    register port_control {
        field lvcat  @ [0:0] is pcie_desc {
            param pcie_desc = "Load VC Arbitration Table";
        }
        field vcas   @ [3:1] is pcie_desc {
            param pcie_desc = "VC Arbitration Select";
        }
    }
    register port_status {
        field vcats  @ [0:0] is pcie_desc {
            param pcie_desc = "VC Arbitration Table Status";
        }
    }
    group resource[i < num_vcs] {
        register capability {
            field pac   @ [7:0] is pcie_desc {
                param pcie_desc default "Port Arbitration Capability";
                param init_val default pat_capability;
            }
#if (pcie_version == 1) {
            field aps  @ [14:14] is pcie_desc {
                param pcie_desc = "Advanced Packet Switching";
            }
}
            field rst   @ [15:15] is pcie_desc {
                param pcie_desc = "Reject Snoop Transactions";
            }
            field mts   @ [22:16] is pcie_desc {
                param pcie_desc = "Maximum Time Slots";
            }
            field pato  @ [31:24] is pcie_desc {
                param pcie_desc default "Port Arbitration Table Offset";
                param init_val default pat_offset / 0x10 + i;
            }
        }
        register control {
            field tcvcm  @ [7:0]   is pcie_desc {
                param pcie_desc = "TC/VC Map";
            }
            field lpat   @ [16:16] is pcie_desc {
                param pcie_desc default "Load Port Arbitration Table";
            }
            field pas    @ [19:17] is pcie_desc {
                param pcie_desc default "Port Arbitration Select";
            }
            field vcid   @ [26:24] is pcie_desc {
                param pcie_desc = "VC ID";
            }
            field vce    @ [31:31] is pcie_desc {
                param pcie_desc = "VC Enable";
            }
        }
        register status {
            field pats  @ [0:0] is pcie_desc {
                param pcie_desc default "Port Arbitration Table Status";
            }
            field vcnp  @ [1:1] is pcie_desc {
                param pcie_desc = "VC Negotiation Pending";
            }
        }
    }

#if (use_standard_access_templates) {
    register port_capability1 is read_only;
    register port_capability2 is read_only;
    register port_status is read_only;
    group resource[i < num_vcs] {
        register capability is read_only;
        register status is read_only;
    }
}
#if (use_standard_write_templates) {
    register port_capability1 is pcie_no_function_level_reset;
    register port_capability2 is pcie_no_function_level_reset;
    register port_control is pcie_no_function_level_reset;
    register port_status is pcie_no_function_level_reset;
    group resource[i < ...] is pcie_no_function_level_reset;
    group arbitration_table[i < ...] is pcie_no_function_level_reset;
}
}

template defining_vc_capability {
    param vc_offset;
    param vc_next_ptr;
    param vc_id;  // 9 if mfvc present, 2 otherwise
    param vc_count;
    param vc_vat_capability;
    param vc_pat_capability;
    param vc_pat_entry_size;

    group vc is vc_capability {
        param id = vc_id;
        param base = vc_offset;
        param next_ptr = vc_next_ptr;
        param num_vcs = vc_count + 1;
        param vat_capability = vc_vat_capability;
        param pat_capability = vc_pat_capability;
        param pat_entry_size = vc_pat_entry_size;
    }
}

/**
   ## Device Serial Number (DSN) Capability registers

    - name: `dsn_capability`
    - implemented: registers only
*/
template dsn_capability is extended_capability {
    param id = 3;
    register serial_number size 8 @ (base + 4) is pcie_desc {
        param pcie_desc = "Serial Number";
    }
#if (use_standard_access_templates) {
    register serial_number is read_only;
}
}

template defining_dsn_capability {
    param dsn_offset;
    param dsn_next_ptr;
    group dsn is dsn_capability {
        param base = dsn_offset;
        param next_ptr = dsn_next_ptr;
    }
}

/**
   ## Device Power Budgeting (DPB) Capability registers

    - name: `dpb_capability`
    - implemented: registers only
*/
template dpb_capability is extended_capability {
    param id = 4;

    register data_select size 1 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Power Budget Data Select";
    }
#if (pcie_version >= 6.0) {
    register control     size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "Power Budgeting Control";
    }
}
    register data        size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Power Budget Data";
    }
    register capability  size 1 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "Power Budget Capability";
    }
#if (pcie_version >= 6.0) {
    register pbsd        size 3 @ (base + 0xd) is pcie_desc {
        param pcie_desc = "Power Budgeting Sense Detect";
    }
}

    register data_select;
#if (pcie_version >= 6.0) {
    register control {
        field epbe    @ [0:0] is pcie_desc {
            param pcie_desc = "Extended Power Budgeting Enable";
        }
        field ple     @ [1:1] is pcie_desc {
            param pcie_desc = "Power Limit Enable";
        }
        field plpss   @ [4:2] is pcie_desc {
            param pcie_desc = "Power Limit PM Sub State";
        }
        field obple   @ [5:5] is pcie_desc {
            param pcie_desc = "Out of Band Power Limit Enable";
        }
        field obplpss @ [8:6] is pcie_desc {
            param pcie_desc = "Out of Band Power Limit PM Sub State";
        }
    }
}
    register data {
        field bp    @ [7:0]   is pcie_desc {
            param pcie_desc = "Base Power";
        }
        field ds    @ [9:8]   is pcie_desc {
            param pcie_desc = "Data Scale";
        }
        field pmss  @ [12:10] is pcie_desc {
            param pcie_desc = "PM Sub State";
        }
        field pms   @ [14:13] is pcie_desc {
            param pcie_desc = "PM State";
        }
        field t     @ [17:15] is pcie_desc {
            param pcie_desc = "Type";
        }
        field pr    @ [20:18] is pcie_desc {
            param pcie_desc = "Power Rail";
        }
#if (pcie_version >= 6.0) {
        field ds2   @ [21:21] is pcie_desc {
            param pcie_desc = "Data Scale [2]";
        }
        field cn    @ [24:22] is pcie_desc {
            param pcie_desc = "Connector Number";
        }
        field ct    @ [30:25] is pcie_desc {
            param pcie_desc = "Connector Type";
        }
        field epbp  @ [31:31] is pcie_desc {
            param pcie_desc = "Extended Power Budgeting Present";
        }
}
    }
    register capability {
        field sa     @ [0:0] is pcie_desc {
            param pcie_desc = "System Allocated";
        }
#if (pcie_version >= 6.0) {
        field epbs   @ [1:1] is pcie_desc {
            param pcie_desc = "Extended Power Budgeting Supported";
        }
        field pbsds  @ [2:2] is pcie_desc {
            param pcie_desc = "Power Budgeting Sense Detect Supported";
        }
        field pls    @ [3:3] is pcie_desc {
            param pcie_desc = "Power Limit Supported";
        }
        field pds    @ [5:4] is pcie_desc {
            param pcie_desc = "Power Disable Supported";
        }
        field plns   @ [7:6] is pcie_desc {
            param pcie_desc = "Power Loss Notification Supported ";
        }
}
    }
#if (pcie_version >= 6.0) {
    register pbsd {
        field cn0sd  @ [2:0] is pcie_desc {
            param pcie_desc = "Connector Number 0 Sense Data";
        }
        field cn1sd  @ [5:3] is pcie_desc {
            param pcie_desc = "Connector Number 1 Sense Data";
        }
        field cn2sd  @ [8:6] is pcie_desc {
            param pcie_desc = "Connector Number 2 Sense Data";
        }
        field cn3sd  @ [11:9] is pcie_desc {
            param pcie_desc = "Connector Number 3 Sense Data";
        }
        field cn4sd  @ [14:12] is pcie_desc {
            param pcie_desc = "Connector Number 4 Sense Data";
        }
        field cn5sd  @ [17:15] is pcie_desc {
            param pcie_desc = "Connector Number 5 Sense Data";
        }
        field cn6sd  @ [20:18] is pcie_desc {
            param pcie_desc = "Connector Number 6 Sense Data";
        }
        field cn7sd  @ [23:21] is pcie_desc {
            param pcie_desc = "Connector Number 7 Sense Data";
        }
    }
}
#if (use_standard_access_templates) {
#if (pcie_version >= 6.0) {
    register control {
        field obple is (hwinit);
        field obplpss is (hwinit);
    }
}
    register data is read_only;
    register capability is hwinit;
#if (pcie_version >= 6.0) {
    register pbsd is read_only;
}
}
#if (use_standard_write_templates) {
    register capability is pcie_sticky;
#if (pcie_version >= 6.0) {
    register control {
        field ple is (pcie_sticky);
        field plpss is (pcie_sticky);
    }
}
}
}

template defining_dpb_capability {
    param dpb_offset;
    param dpb_next_ptr;

    group dpb is dpb_capability {
        param base = dpb_offset;
        param next_ptr = dpb_next_ptr;
    }
}

/**
   ## Root Complex Link Declaration (RCLD) Capability registers

    - name: `rcld_capability`
    - implemented: registers only

   Uses the following parameters:
   * `num_links`: number of links.

*/
template rcld_capability is extended_capability {
    param id = 5;
    param num_links default 1;

    register element_self_desc size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Element Self Description";
    }
    group link[i < num_links] {
        register desc size 4 @ (base + i * 0x10 + 0xc)  is pcie_desc {
            param pcie_desc = "Link Description";
        }
        register addr size 8 @ (base + i * 0x10 + 0x14) is pcie_desc {
            param pcie_desc = "Link Address";
        }
    }

    register element_self_desc {
        field et   @ [3:0]  is pcie_desc {
            param pcie_desc = "Element Type";
        }
        field nle  @ [15:8] is pcie_desc {
            param pcie_desc = "Number of Link Entries";
            param init_val default num_links;
        }
        field cid  @ [23:16] is pcie_desc {
            param pcie_desc = "Component ID";
        }
        field pn   @ [31:24] is pcie_desc {
            param pcie_desc = "Port Number";
        }
    }

    group link[i < num_links] {
        register desc {
            field lv      @ [0:0]   is pcie_desc {
                param pcie_desc = "Link Valid";
            }
            field lt      @ [1:1]   is pcie_desc {
                param pcie_desc = "Link Type";
            }
            field arcrbh  @ [2:2]   is pcie_desc {
                param pcie_desc = "Associate RCRB Header";
            }
            field tcid    @ [23:16] is pcie_desc {
                param pcie_desc = "Target Component ID";
            }
            field tpn     @ [31:24] is pcie_desc {
                param pcie_desc = "Target Port Number";
            }
        }
    }

#if (use_standard_access_templates) {
    register element_self_desc {
        field et  is ignore_write;
        field nle is hwinit;
        field cid is hwinit;
        field pn  is hwinit;
    }
    group link[i < num_links] {
        register desc {
            field lv     is hwinit;
            field lt     is hwinit;
            field arcrbh is hwinit;
            field tcid   is hwinit;
            field tpn    is hwinit;
        }
        register addr is hwinit;
    }
}
#if (use_standard_write_templates) {
    register element_self_desc {
        field et  is ignore_write;
        field nle is pcie_sticky;
        field cid is pcie_sticky;
        field pn  is pcie_sticky;
    }
    group link[i < num_links] {
        register desc {
            field lv     is pcie_sticky;
            field lt     is pcie_sticky;
            field arcrbh is pcie_sticky;
            field tcid   is pcie_sticky;
            field tpn    is pcie_sticky;
        }
        register addr is pcie_sticky;
    }
}
}

template defining_rcld_capability {
    param rcld_offset;
    param rcld_next_ptr;
    param rcld_num_links default 1;
    group rcld {
        param base = rcld_offset;
        param next_ptr = rcld_next_ptr;
        param num_links = rcld_num_links;
    }
}

/**
   ## Root Complex Internal Link Control (RCILC) Capability registers

    - name: `rcilc_capability`
    - implemented: registers only
*/
template rcilc_capability is extended_capability {
    param id = 6;

    register capability   size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Root Complex Link Capabilities";
    }
    register control      size 2 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Root Complex Link Control";
    }
    register status       size 2 @ (base + 0xa) is pcie_desc {
        param pcie_desc = "Root Complex Link Status";
    }

    register capability {
        field mlw    @ [9:4]   is pcie_desc {
            param pcie_desc = "Maximum Link Width";
        }
        field aspms  @ [11:10] is pcie_desc {
            param pcie_desc = "Active State Power Management Support";
        }
        field l0el   @ [14:12] is pcie_desc {
            param pcie_desc = "L0s Exit Latency";
        }
        field l1el   @ [17:15] is pcie_desc {
            param pcie_desc = "L1 Exit Latency";
        }
    }
    register control {
        field aspmc  @ [1:0] is pcie_desc {
            param pcie_desc = "Active State Power Management Control";
        }
        field es     @ [7:7] is pcie_desc {
            param pcie_desc = "Extended Sync";
        }
    }
    register status {
        field cls  @ [ 3: 0] is pcie_desc {
            param pcie_desc = "Current Link Speed";
        }
        field nlw  @ [ 9: 4] is pcie_desc {
            param pcie_desc = "Negotiated Link Width";
        }
    }
#if (pcie_version == 2.0) {
    register capability {
        field sls  @ [3:0] is pcie_desc {
            param pcie_desc = "Supported Link Speeds";
        }
    }
}

#if (pcie_version >= 3.0) {
    register capability   {
        field mls   @ [3:0]   is pcie_desc {
            param pcie_desc = "Max Link Speed";
        }
        field slsv  @ [24:18] is pcie_desc {
            param pcie_desc = "Supported Link Speeds Vector";
        }
    }
}

#if (use_standard_access_templates) {
    register capability   is read_only;
    register status is read_only;
}
}

template defining_rcilc_capability {
    param rcilc_offset;
    param rcilc_next_ptr;

    group rcilc is rcilc_capability {
        param base = rcilc_offset;
        param next_ptr = rcilc_next_ptr;
    }
}

/**
   ## Root Complex Event Collector Endpoint Association (RCECEA) Capability registers

    - name: `rcecea_capability`
    - implemented: registers only

   Uses the following parameters:
   * `version`: version number of this capability, default 2
*/
template rcecea_capability is extended_capability {
    param id = 7;
    param version default 2;

    register bitmap     size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Association Bitmap for RCiEPs";
    }
#if (version >= 2) {
    register busnumbers size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "RCEC Associated Bus Numbers";
        field nb @ [15:8]  is pcie_desc {
            param pcie_desc = "Next Bus";
        }
        field lb @ [23:16] is pcie_desc {
            param pcie_desc = "Last Bus";
        }
    }
}

#if (use_standard_access_templates) {
    register bitmap is read_only;
#if (version >= 2) {
    register busnumbers {
        field nb is hwinit;
        field lb is hwinit;
    }
}
}
#if (use_standard_write_templates) {
#if (version >= 2) {
    register busnumbers {
        field nb is pcie_sticky;
        field lb is pcie_sticky;
    }
}
}
}

template defining_rcecea_capability {
    param rcecea_offset;
    param rcecea_version default 2;
    param rcecea_next_ptr;

    group rcecea is rcecea_capability {
        param base = rcecea_offset;
        param next_ptr = rcecea_next_ptr;
        param version = rcecea_version;
    }
}

/**
   ## Multi-Function Virtual Channel (MFVC) Capability registers

    - name: `mfvc_capability`
    - implemented: registers only
*/
template mfvc_capability is vc_capability {
    param id = 8;

    /* Mostly identical to VC capability, just need to override some
       cosmetics, like doc-strings and names */
#if (pat_offset > 0) {
    group arbitration_table[i < num_vcs] {
        register port[j < ...] {
            param pcie_desc default "Function Arbitration Table";
            param name default "fun";
        }
    }
}
    register port_capability1 {
        field pates is pcie_desc {
            param pcie_desc = "Function Arbitration Table Entry Size";
            param name default "fates";
        }
    }
    group resource[i < num_vcs] {
        register capability {
            field pac is pcie_desc {
                param pcie_desc = "Function Arbitration Capability";
                param name default "pac";
            }
            field pato is pcie_desc {
                param pcie_desc = "Function Arbitration Table Offset";
                param name default "fato";
            }
        }
        register control {
            field lpat is pcie_desc {
                param pcie_desc = "Load Function Arbitration Table";
                param name default "lfat";
            }
            field pas is pcie_desc  {
                param pcie_desc = "Function Arbitration Select";
                param name default "fas";
            }
        }
        register status {
            field pats {
                param pcie_desc = "Function Arbitration Table Status";
                param name default "fats";
            }
        }
    }
}

template defining_mfvc_capability {
    param mfvc_offset;
    param mfvc_next_ptr;
    param mfvc_count;
    param mfvc_vat_capability;
    param mfvc_fat_capability;
    param mfvc_fat_entry_size;

    group mfvc is mfvc_capability {
        param base = mfvc_offset;
        param next_ptr = mfvc_next_ptr;
        param num_vcs = mfvc_count + 1;
        param vat_capability = mfvc_vat_capability;
        param pat_capability = mfvc_fat_capability;
        param pat_entry_size = mfvc_fat_entry_size;
    }
}

/**
   ## RCRB Header (RCRB) Capability registers

    - name: `rcrb_capability`
    - implemented: registers only
*/
template rcrb_capability is extended_capability {
    param id = 0xa;

    register vendor_id  size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Vendor ID";
    }
    register device_id  size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "Device ID";
    }
    register capability size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "RCRB Capabilities";
    }
    register control    size 4 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "RCRB Control";
    }

    register capability   {
        field crssv  @ [0:0]  is pcie_desc {
            param pcie_desc = "CRS Software Visibility";
        }
    }
    register control {
        field crssve  @ [0:0] is pcie_desc {
            param pcie_desc = "CRS Software Visibility Enable";
        }
    }

#if (use_standard_access_templates) {
    register device_id is read_only;
    register capability is read_only;
}
}

template defining_rcrb_capability {
    param rcrb_offset;
    param rcrb_next_ptr;

    group rcrb is rcrb_capability {
        param base = rcrb_offset;
        param next_ptr = rcrb_next_ptr;
    }
}

/**
   ## Vendor-Specific Extended Capability (VSEC) registers

    - name: `vsec_capability`
    - implemented: registers only
*/
template vsec_capability is extended_capability {
    param id = 0xb;

    register header size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Vendor-Specific Header";
        field id  @ [15:0]  is pcie_desc {
            param pcie_desc = "ID";
        }
        field rev @ [19:16] is pcie_desc {
            param pcie_desc = "Revision";
        }
        field len @ [31:20] is pcie_desc {
            param pcie_desc = "Length";
        }
    }

#if (use_standard_access_templates) {
    register header is read_only;
}
}

template defining_vsec_capability {
    param vsec_offset;
    param vsec_next_ptr;

    group vsec is vsec_capability {
        param base = vsec_offset;
        param next_ptr = vsec_next_ptr;
    }
}

/**
   ## Access Control Services (ACS) Capability registers

    - name: `acs_capability`
    - implemented: registers only
*/
template acs_capability is extended_capability {
    param id = 0xd;

    register capability        size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "ACS Capability";
    }
    register control           size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "ACS Control";
    }
    register egress_control    size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "ACS Egress Control";
    }

    register capability {
        field v  @ [0:0]  is pcie_desc {
            param pcie_desc = "Source Validation (V)";
        }
        field b  @ [1:1]  is pcie_desc {
            param pcie_desc = "Translation Blocking (B)";
        }
        field r  @ [2:2]  is pcie_desc {
            param pcie_desc = "P2P Request Redirect (R)";
        }
        field c  @ [3:3]  is pcie_desc {
            param pcie_desc = "P2P Completion Redirect (C)";
        }
        field u  @ [4:4]  is pcie_desc {
            param pcie_desc = "Upstream Forwarding (U)";
        }
        field e  @ [5:5]  is pcie_desc {
            param pcie_desc = "P2P Egress Control (E)";
        }
        field t  @ [6:6]  is pcie_desc {
            param pcie_desc = "Direct Translated P2P (T)";
        }
        field s  @ [15:8] is pcie_desc {
            param pcie_desc = "Egress Control Vector Size (S)";
        }
    }
    register control {
        field v  @ [0:0] is pcie_desc {
            param pcie_desc = "Source Validation Enable (V)";
        }
        field b  @ [1:1] is pcie_desc {
            param pcie_desc = "Translation Blocking Enable (B)";
        }
        field r  @ [2:2] is pcie_desc {
            param pcie_desc = "P2P Request Redirect Enable (R)";
        }
        field c  @ [3:3] is pcie_desc {
            param pcie_desc = "P2P Completion Redirect Enable (C)";
        }
        field u  @ [4:4] is pcie_desc {
            param pcie_desc = "Upstream Forwarding Enable (U)";
        }
        field e  @ [5:5] is pcie_desc {
            param pcie_desc = "P2P Egress Control Enable (E)";
        }
        field t  @ [6:6] is pcie_desc {
            param pcie_desc = "Direct Translated P2P Enable (T)";
        }
    }

#if (use_standard_access_templates) {
    register capability {
        field v is ignore_write;
        field b is ignore_write;
        field r is ignore_write;
        field c is ignore_write;
        field u is ignore_write;
        field e is ignore_write;
        field t is ignore_write;
        field s is hwinit;
    }
}
#if (use_standard_write_templates) {
    register capability {
        field s is pcie_sticky;
    }
}
}

template defining_acs_capability {
    param acs_offset;
    param acs_next_ptr;

    group acs is acs_capability {
        param base = acs_offset;
        param next_ptr = acs_next_ptr;
    }
}

/**
   ## Alternate Routing ID (ARI) Capability registers

    - name: `ari_capability`
    - implemented: registers only
*/
template ari_capability is extended_capability {
    param id = 0xe;

    register capability size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "ARI Capability Register";
    }
    register control    size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "ARI Control Register";
    }

    register capability {
        field m    @ [0:0] is pcie_desc {
            param pcie_desc = "MFVC Function Groups Capability (M)";
        }
        field a    @ [1:1] is pcie_desc {
            param pcie_desc = "ACS Function Groups Capability (A)";
        }
        field nfn  @ [15:8] is pcie_desc {
            param pcie_desc = "Next Function Number";
        }
    }
    register control {
        field m   @ [0:0] is pcie_desc {
            param pcie_desc = "MFVC Function Groups Enable (M)";
        }
        field a   @ [1:1] is pcie_desc {
            param pcie_desc = "ACS Function Groups Enable (A)";
        }
        field fg  @ [6:4] is pcie_desc {
            param pcie_desc = "Function Group";
        }
    }

#if (use_standard_access_templates) {
    register capability is read_only;
}
#if (use_standard_write_templates) {
    /* Ignore FLR according to spec only required if MUST@FLT is
     * set otherwise strongly recommended.
     */
    register control is pcie_no_function_level_reset;
}
}

template defining_ari_capability {
    param ari_offset;
    param ari_next_ptr;

    group ari is ari_capability {
        param base = ari_offset;
        param next_ptr = ari_next_ptr;
    }
}

/**
   ## Address Translation Service (ATS) Capability registers

    - name: `ats_capability`
    - implemented: functional

   This is a partially functional template; the user must implement the method
   `invalidate_received`.

   ### Methods
*/
template ats_capability is extended_capability {
    param id = 0xf;

    register capability size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "ATS Capabilities";
        field mas @ [8] is pcie_desc {
            param pcie_desc = "Memory Attributes Supported";
        }
        field ros @ [7] is pcie_desc {
            param pcie_desc = "Relaxed Ordering Supported";
        }
        field gis @ [6] is pcie_desc {
            param pcie_desc = "Global Invalidate Supported";
        }
        field par @ [5] is pcie_desc {
            param pcie_desc = "Page Aligned Request";
            param init_val default 1;
        }
        field iqd @ [4:0] is pcie_desc {
            param pcie_desc = "Invalidate Queue Depth";
        }
    }
    register control size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "ATS Control";
        field enable  @ [15]    is pcie_desc {
            param pcie_desc = "Enable";
        }
        field mae     @ [14]    is pcie_desc {
            param pcie_desc = "Memory Attributes Enable";
        }
        field mad     @ [13:11] is pcie_desc {
            param pcie_desc = "Memory Attributes Default";
        }
        field stu     @ [4:0]   is pcie_desc {
            param pcie_desc = "Smallest Translation Unit";
            method size() -> (uint64) {
                return 4096 << this.val;
            }
            method lsbit() -> (int) {
                return 12 + this.val;
            }
        }
    }

    /**
       #### `invalidate_received(transaction_t *t, uint64 addr) -> (bool)`

       Called by the standard PCIe templates when an ATS Invalidate message
       is received. The default implementation logs an `unimpl` message and
       returns `false`, indicating a 'Completer Abort'.
    */
    shared method invalidate_received(transaction_t *t,
                                      uint64 addr) -> (bool) default {
        local pcie_ats_invalidate_request_payload_t payload;
        payload.u64 = SIM_get_transaction_value_le(t);

        local uint8 itag = ATOM_get_transaction_pcie_ats_invalidate_request_itag(t);
        log unimpl: "ATS Invalidate for 0x%llx, ITAG:%d, PASID:%d",
            payload.field.untranslated_addr << 12, itag, ATOM_get_transaction_pcie_pasid(t);
        return false;
    }

    /**
        #### `translation_request(unint64 addr, pcie_ats_translation_completion_entry_t *entries, int nbr_entries, const pcie_pasid_info_t *pasid, bool no_write, bool cxl_src)-> (pcie_error_t, int)`

        Issue a translation request to Translation Agent (TA).
        Set `pasid` to NULL to exclude the `pcie_pasid` atom in the transaction.
        Returns error status and number of valid completion entries
        the TA has filled in.
     */
    method translation_request(uint64 addr,
                               pcie_ats_translation_completion_entry_t *entries,
                               int nbr_entries,
                               const pcie_pasid_info_t *pasid,
                               bool no_write,
                               bool cxl_src)
                               -> (pcie_error_t, // Error
                                   int)          // Number of entries with valid content
                               {
        return translation_request_custom(addr, entries, nbr_entries, pasid,
            no_write, cxl_src, NULL);
    }

    /**
        #### `translation_request_custom(unint64 addr, pcie_ats_translation_completion_entry_t *entries, int nbr_entries, const pcie_pasid_info_t *pasid, bool no_write, bool cxl_src, atom_t *extra_atoms)-> (pcie_error_t, int)`

         A variant of
         [`translation_request()`](#translation_request-unint64-addr-pcie_ats_translation_completion_entry_t-entries-int-nbr_entries-const-pcie_pasid_info_t-pasid-bool-no_write-bool-cxl_src-pcie_error_t-int)
         that allows the user to add custom atoms to the transaction. The
         `extra_atoms` parameter is a list of atoms to be added to the
         transaction. The list must be terminated with `ATOM_list_end(0)`.
     */
    method translation_request_custom(uint64 addr,
        pcie_ats_translation_completion_entry_t *entries, int nbr_entries,
        const pcie_pasid_info_t *pasid, bool no_write, bool cxl_src,
        atom_t *extra_atoms) -> (pcie_error_t, // Error
                                 int)          // Number of entries with valid content
        {
        if (!control.enable.val) {
            log error: "%s ATS is disabled, cannot do address translation requests",
                this.qname;
            return (PCIE_Error_Master_Abort, 0);
        }
        if (capability.par.val == 1 && addr[11:0] != 0) {
            log spec_viol: "%s address 0x%08X must be aligned to a 4096 boundary", this.qname, addr;
            addr[11:0] = 0;
        }

        if (pasid != NULL)
            verify_pasid_with_at(*pasid, PCIE_AT_Translation_Request);

        local int num_extra_atoms;
        if (extra_atoms != NULL) {
            local const atom_t *a;
            for (a = extra_atoms; a->id != Sim_Atom_Id_list_end; a++)
                num_extra_atoms++;
        }
        local pcie_byte_count_ret_t bc;
        local atom_t atoms[6 + num_extra_atoms];
        local int j = 0;
        atoms[j++] = ATOM_pcie_at(PCIE_AT_Translation_Request);
        atoms[j++] = ATOM_pcie_ats_translation_request_no_write(no_write);
        atoms[j++] = ATOM_pcie_ats_translation_request_cxl_src(cxl_src);
        atoms[j++] = ATOM_pcie_byte_count_ret(&bc);
        atoms[j++] = pasid != NULL ? ATOM_pcie_pasid(pasid->u32) : ATOM_list_end(0);
        for (local int i = 0; i < num_extra_atoms; i++)
            atoms[j++] = extra_atoms[i];
        atoms[j] = ATOM_list_end(0);
        local buffer_t buf = {
            .data = cast(entries, uint8 *),
            .len = sizeof(entries[0]) * nbr_entries
        };

        // issue_transaction() adds requester id
        local pcie_error_t ret = memory.read_custom(addr, buf, atoms);
        if (ret == PCIE_Error_No_Error)
            return (ret, bc.val / sizeof(entries[0]));
        else
            return (ret, 0);
    }

    /**
        #### `translation_size_to_entries(uint64 size) -> (uint64)`

        Calculates the maximum number of translation completion entries required
        for TA to cover the requested translation of `size`.
     */
    method translation_size_to_entries(uint64 size) -> (uint64) {
        local uint64 tl_size = control.stu.size();
        return (size + tl_size - 1) / tl_size;
    }

    /**
        #### `get_translation_range(pcie_ats_translation_completion_entry_t entry) -> (uint64, uint64)`

        Decodes the completion entry and returns the `translated` address
        and the `size` of the translated region.
     */
    method get_translation_range(pcie_ats_translation_completion_entry_t entry) ->
                                    (
                                    uint64,  // Translated Address
                                    uint64   // Translated Size
                                    ) {
        /*
         * From PCIe Spec:
         * If S is Set, then the translation applies to a range that is larger
         * than 4096 bytes. If S = 1b, then bit 12 of the Translated
         * Address is used to indicate whether or not the range is larger than 8192 bytes.
         * If bit 12 is 0b, then the range size is 8192 bytes, but it is larger
         * than 8192 bytes if Set. If S = 1b and bit 12 = 1b, then bit 13 is used
         * to determine if the range is larger than 16384 bytes or not.
         * If bit 13 is 0b, then the range size is 16384 bytes, but it is larger than 16384 bytes if Set.
         * Low-order address bits are consumed in sequence to indicate the size of the range
         * associated with the translation.
         */

        if (entry.field.s == 0)
            return (entry.field.translated_addr << 12, 4096);

        // Invert so count_trailing_zeros() macro can be used
        local uint64 a = ~entry.field.translated_addr;
        local uint64 size = 8192 << count_trailing_zeros64(a);
        local int sb = log2_64(size);
        return (entry.u64[63:sb] << sb, size);
    }

    /**
        #### `get_invalidation_range(pcie_ats_invalidate_request_payload_t payload) -> (uint64, uint64)`

        Decodes the invalidation request message and returns the `untranslated` address
        and the `size` of the untranslated region.
     */
    method get_invalidation_range(pcie_ats_invalidate_request_payload_t payload) ->
                                      (
                                       uint64,  // Untranslated Address
                                       uint64   // Size
                                      ) {
        if (!payload.field.s)
            return (payload.field.untranslated_addr << 12, 4096);
        // Invert so count_trailing_zeros() macro can be used
        local uint64 a = ~payload.field.untranslated_addr;
        local uint64 size = 8192 << (count_trailing_zeros64(a));
        local int sb = log2_64(size);
        return (payload.u64[63:sb] << sb, size);
    }

    /**
        #### `invalidate_complete(uint64 destination_id, uint32 itag_vector) -> (pcie_error_t)`

        Sends the invalidation message to TA found at B:D:F `destination_id`.
        Returns PCIE_Error_No_Error on success.
     */
    method invalidate_complete(uint16 destination_id,
                               uint32 itag_vector)  -> (pcie_error_t) {
        local atom_t atoms[2] = {
            ATOM_pcie_ats_invalidate_completion_itag_vector(itag_vector),
            ATOM_list_end(0),
        };
        local bytes_t bytes;
        return message.send_custom(destination_id << 48,
                                   PCIE_ATS_Invalidate_Completion,
                                   PCIE_Msg_Route_ID,
                                   bytes,
                                   atoms);
    }

    /**
       #### `memory_read_buf(buffer_t buf, uint64 addr, pcie_at_t at, const pcie_pasid_info_t *pasid) -> (pcie_error_t)`

       Performs an ATS Translated/Untranslated Memory Read.
       The input argument `at` specifies which AT type. Input argument `pasid`
       contains PASID, set to NULL to exclude the `pcie_pasid` atom in
       the transaction. Returns a pcie_error_t.
       Requires that an `upstream_target` is defined.
       Should only be used with `at` set to: PCIE_AT_Untranslated
       or PCIE_AT_Translated.
    */
    method memory_read_buf(buffer_t buf,
                           uint64 addr,
                           pcie_at_t at,
                           const pcie_pasid_info_t *pasid) -> (pcie_error_t) {
        return memory_read_custom(buf, addr, at, pasid, NULL);
    }

    /**
       #### `memory_read_custom(buffer_t buf, uint64 addr, pcie_at_t at, const pcie_pasid_info_t *pasid, atom_t *extra_atoms) -> (pcie_error_t)`

         A variant of
         [`memory_read_buf()`](#memory_read_buf-buffer_t-buf-uint64-addr-pcie_at_t-at-const-pcie_pasid_info_t-pasid-pcie_error_t)
         that allows the user to add custom atoms to the transaction. The
         `extra_atoms` parameter is a list of atoms to be added to the
         transaction. The list must be terminated with `ATOM_list_end(0)`.
    */
    method memory_read_custom(buffer_t buf, uint64 addr, pcie_at_t at,
        const pcie_pasid_info_t *pasid, atom_t *extra_atoms) -> (pcie_error_t) {
        if (!upstream_target.connected())
            return PCIE_Error_Master_Abort;

        if (pasid != NULL)
            verify_pasid_with_at(*pasid, at);

        local int num_extra_atoms;
        if (extra_atoms != NULL) {
            local const atom_t *a;
            for (a = extra_atoms; a->id != Sim_Atom_Id_list_end; a++)
                num_extra_atoms++;
        }

        local atom_t atoms[3 + num_extra_atoms];
        local int j = 0;
        atoms[j++] = ATOM_pcie_at(at);
        atoms[j++] = pasid != NULL ? ATOM_pcie_pasid(pasid->u32) : ATOM_list_end(0);
        for (local int i = 0; i < num_extra_atoms; i++)
            atoms[j++] = extra_atoms[i];
        atoms[j] = ATOM_list_end(0);

        return memory.read_custom(addr, buf, atoms);
    }

    /**
       #### `memory_write_bytes(bytes_t bytes, uint64 addr, pcie_at_t at, const pcie_pasid_info_t *pasid) -> (pcie_error_t)`

       Performs an ATS Translated/Untranslated Memory Write.
       The input argument `at` specifies which AT type. Input argument `pasid`
       contains PASID, set to NULL to exclude the `pcie_pasid` atom in
       the transaction. Returns a pcie_error_t.
       Requires that an `upstream_target` is defined.
       Should only be used with `at` set to: PCIE_AT_Untranslated
       or PCIE_AT_Translated.
    */
    method memory_write_bytes(bytes_t bytes,
                              uint64 addr,
                              pcie_at_t at,
                              const pcie_pasid_info_t *pasid) -> (pcie_error_t) {
        return memory_write_custom(bytes, addr, at, pasid, NULL);
    }

    /**
       #### `memory_write_custom(bytes_t bytes, uint64 addr, pcie_at_t at, const pcie_pasid_info_t *pasid, atom_t *extra_atoms) -> (pcie_error_t)`

         A variant of
         [`memory_write_bytes()`](#memory_write_bytes-bytes_t-bytes-uint64-addr-pcie_at_t-at-const-pcie_pasid_info_t-pasid-pcie_error_t)
         that allows the user to add custom atoms to the transaction. The
         `extra_atoms` parameter is a list of atoms to be added to the
         transaction. The list must be terminated with `ATOM_list_end(0)`.
    */
    method memory_write_custom(bytes_t bytes, uint64 addr, pcie_at_t at,
            const pcie_pasid_info_t *pasid, atom_t *extra_atoms) ->
            (pcie_error_t) {
        if (!upstream_target.connected())
            return PCIE_Error_Master_Abort;

        if (pasid != NULL)
            verify_pasid_with_at(*pasid, at);

        local int num_extra_atoms;
        if (extra_atoms != NULL) {
            local const atom_t *a;
            for (a = extra_atoms; a->id != Sim_Atom_Id_list_end; a++)
                num_extra_atoms++;
        }

        local atom_t atoms[3 + num_extra_atoms];
        local int j = 0;
        atoms[j++] = ATOM_pcie_at(at);
        atoms[j++] = pasid != NULL ? ATOM_pcie_pasid(pasid->u32) : ATOM_list_end(0);
        for (local int i = 0; i < num_extra_atoms; i++)
            atoms[j++] = extra_atoms[i];
        atoms[j] = ATOM_list_end(0);

        return memory.write_custom(addr, bytes, atoms);
    }

#if (use_standard_access_templates) {
    register capability is read_only;
}
}

template defining_ats_capability {
    param ats_offset;
    param ats_next_ptr;

    group ats is ats_capability {
        param base = ats_offset;
        param next_ptr = ats_next_ptr;
    }
}

/**
   ## Multicast (MC) Capability registers

    - name: `mc_capability`
    - implemented: registers only
*/
template mc_capability is extended_capability {
    param id = 0x12;

    register capability    size 2 @ (base + 0x4)  is pcie_desc {
        param pcie_desc = "Multicast Capability";
    }
    register control       size 2 @ (base + 0x6)  is pcie_desc {
        param pcie_desc = "Multicast Control";
    }
    register bar           size 8 @ (base + 0x8)  is pcie_desc {
        param pcie_desc = "Multicast Base Address";
    }
    register receive       size 8 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "Multicast Receive";
    }
    register block_all     size 8 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "Multicast Block All";
    }
    register block_untrans size 8 @ (base + 0x20) is pcie_desc {
        param pcie_desc = "Multicast Block Untranslated";
    }
    register overlay       size 8 @ (base + 0x28) is pcie_desc {
        param pcie_desc = "Multicast Overlay Base Address";
    }

    register capability {
        field mmg   @ [5:0]   is pcie_desc {
            param pcie_desc = "Multicast Max Group";
        }
        field mrws  @ [13:8]  is pcie_desc {
            param pcie_desc = "Multicast Required Window Size";
        }
        field mers  @ [15:15] is pcie_desc {
            param pcie_desc = "ECRC Regeneration Supported";
        }
    }
    register control {
        field nmg  @ [5:0]   is pcie_desc {
            param pcie_desc = "Number of Multicast Groups";
        }
        field me   @ [15:15] is pcie_desc {
            param pcie_desc = "Multicast Enable";
        }
    }
    register bar {
        field mip  @ [5:0]   is pcie_desc {
            param pcie_desc = "Multicast Index Position";
        }
        field mba  @ [63:12] is pcie_desc {
            param pcie_desc = "Multicast Base Address";
        }
    }
    register overlay {
        field mos    @ [5:0]   is pcie_desc {
            param pcie_desc = "Multicast Overlay Size";
        }
        field mobar  @ [63: 6] is pcie_desc {
            param pcie_desc = "Multicast Overlay BAR";
        }
    }

#if (use_standard_access_templates) {
    register capability is read_only;
}
}

template defining_mc_capability {
    param mc_offset;
    param mc_next_ptr;

    group mc is mc_capability {
        param base = mc_offset;
        param next_ptr = mc_next_ptr;
    }
}

/**
   ## Page Request Service (PRS) Capability registers

    - name: `prs_capability`
    - implemented: register definitions and methods to send and receive PRS message.
    - model specific: Method `page_group_response_received` has to be overridden with device logic. Registers `status` and `alloc` has to be implemented if required.
*/
template prs_capability is extended_capability {
    param id = 0x13;

    register control  size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Page Request Control";
    }
    register status   size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "Page Request Status";
    }
    register capacity size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Page Request Capacity";
    }
    register alloc    size 4 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "Page Request Allocation";
    }

    register control {
        field reset  @ [1] is pcie_desc {
            param pcie_desc = "Reset";
        }
        field enable @ [0] is pcie_desc {
            param pcie_desc = "Enable";
        }
    }
    register status {
        field pasid   @ [15] is pcie_desc {
            param pcie_desc = "PRG Response PASID Required";
        }
        field stopped @ [8]  is pcie_desc {
            param pcie_desc = "Stopped";
            param init_val default 1;
        }
        field uprgi @ [1] is pcie_desc {
            param pcie_desc = "Unexpected PRGI received";
        }
        field rf    @ [0] is pcie_desc {
            param pcie_desc = "Response Failure";
        }
    }

    /**
       #### `page_request(pcie_prs_page_request_t request, const pcie_pasid_info_t *pasid) -> (pcie_error_t)`

       Sends a Page Request message. Input argument `pasid`
       contains PASID, set to NULL to exclude the `pcie_pasid` atom in
       the transaction.
    */
    method page_request(pcie_prs_page_request_t request,
                        const pcie_pasid_info_t *pasid) -> (pcie_error_t) {
        if (!upstream_target.connected())
            return PCIE_Error_Master_Abort;

        if (!control.enable.val) {
            log spec_viol: "%s, Cannot perform page request while PRS is disabled: %s",
                this.qname, control.enable.qname;
            return PCIE_Error_Master_Abort;
        }

        if (pasid != NULL)
            verify_pasid(*pasid);

        local atom_t atoms[3] = {
            ATOM_pcie_prs_page_request(request.u64),
            pasid != NULL ? ATOM_pcie_pasid(pasid->u32) : ATOM_list_end(0),
            ATOM_list_end(0),
        };
        local bytes_t bytes;
        return message.send_custom(0,
                                   PCIE_PRS_Request,
                                   PCIE_Msg_Route_Upstream,
                                   bytes,
                                   atoms);
    }
    /**
       #### `send_stop_marker(const pcie_pasid_info_t *pasid) -> (pcie_error_t)`

       Sends a stop marker message upstream. Input argument `pasid`
       contains PASID, set to NULL to exclude the `pcie_pasid` atom from
       the transaction.
    */
    method send_stop_marker(const pcie_pasid_info_t *pasid) -> (pcie_error_t) {
        if (!upstream_target.connected())
            return PCIE_Error_Master_Abort;

        if (!control.enable.val) {
            log spec_viol: "%s, Cannot perform page stop marker while PRS is disabled: %s",
                this.qname, control.enable.qname;
            return PCIE_Error_Master_Abort;
        }

        if (pasid != NULL)
            verify_pasid(*pasid);

        local atom_t atoms[3] = {
            ATOM_pcie_prs_stop_marker(true),
            pasid != NULL ? ATOM_pcie_pasid(pasid->u32) : ATOM_list_end(0),
            ATOM_list_end(0),
        };
        local bytes_t bytes;
        return message.send_custom(0,
                                   PCIE_PRS_Request,
                                   PCIE_Msg_Route_Upstream,
                                   bytes,
                                   atoms);
    }
    shared method response_code_name(pcie_prs_response_code_t code) -> (const char *) {
        switch(code) {
        case PCIE_PRS_Response_Success:         return "Success";
        case PCIE_PRS_Response_Invalid_Request: return "Invalid request";
        case PCIE_PRS_Response_Failure:         return "Response Failure";
        default:                                return "Unknown";
        }
    }
    /**
       #### `page_response_received(transaction_t *t, uint64 addr) -> (bool)`

         Called by the standard PCIe templates when a Page Response message is
         received. The default implementation logs an `unimpl` message and
         returns `false`.
    */
    shared method page_response_received(transaction_t *t,
                                         uint64 addr) -> (bool) default {
        if (ATOM_transaction_pcie_prs_page_group_response(t) != NULL) {
            local pcie_prs_page_group_response_t msg = {
                .u16 = ATOM_get_transaction_pcie_prs_page_group_response(t),
                ...
            };
            log unimpl: "PRG Response Message: Response %s, PRGI:%d PASID:%d",
                response_code_name(msg.field.response_code),
                msg.field.prgi,
                ATOM_get_transaction_pcie_pasid(t);
        }
        return false;
    }

#if (use_standard_access_templates) {
    register status {
        field stopped is ignore_write;
        field pasid is ignore_write;
    }
    register capacity is read_only;
}
#if (use_standard_write_templates) {
    register status {
        field uprgi   is pcie_write_1_clears;
        field rf      is pcie_write_1_clears;
    }
}
}

template defining_prs_capability {
    param prs_offset;
    param prs_next_ptr;

    group prs is prs_capability {
        param base = prs_offset;
        param next_ptr = prs_next_ptr;
    }
}

/*
  Resizable BAR (RBAR) Capability, base template common for VF and PF registers
*/
template _resizable_bar_capability is extended_capability {
    param num_bars;
    param bar_indexes;
    param bar_capabilities;

    group bar[i < num_bars] {
        param caps = (control.cap.val << 28) | capability.val[31:4];

        param base = parent.base + 0x4 + 0x8 * i;
        register capability size 4 @ (base + 0x0);
        register control    size 4 @ (base + 0x4);

        register capability {
            method pcie_init() {
                // Can't use variable index in constant list
                local int j;
                #foreach v in (bar_capabilities) {
                    if (i == j)
                        this.val[31:4] = v[27:0];
                    ++j;
                }
            }
        }

        register control {
            field id  @ [2:0] {
                method pcie_init() {
                    // Can't use variable index in constant list
                    local int j;
                    #foreach v in (bar_indexes) {
                        if (i == j)
                            this.val = v;
                        ++j;
                    }
                }
            }
            field num @ [7:5] {
                param init_val default i == 0 ? num_bars : 0;
            }
            field sz  @ [13:8] {
                method pcie_write(uint64 value) {
                    if (caps[value] == 1) {
                        this.val = value;
                    } else {
                        log spec_viol: "Unsupported BAR Size '%d'"
                            + " written to '%s'", value, qname;
                    }
                }
            }
            field cap @ [31:16] {
                method pcie_init() {
                    // Can't use variable index in constant list
                    local int j;
                    #foreach v in (bar_capabilities) {
                        if (i == j)
                            this.val = v[43:28];
                        ++j;
                    }
                }
            }
        }
    }

#if (use_standard_access_templates) {
    group bar[i < num_bars] {
        register capability is (read_only);
        register control {
            field id  is (ignore_write);
            field num is ignore_write;
            field cap is (ignore_write);
        }
    }
}
#if (use_standard_write_templates) {
    group bar[i < num_bars] {
        register capability is (pcie_init);
        register control {
            field id  is (pcie_init);
            field sz  is pcie_write;
            field cap is (pcie_init);
        }
    }
}
}

template _resizable_bar_control is register {
    shared method get_id() -> (uint8);
    method get_id() -> (uint8) default {
        return id.get();
    }

    shared method get_size_bits() -> (uint8);
    method get_size_bits() -> (uint8) default {
        return sz.get() + 20;
    }
}

template vf_rbar_control is _resizable_bar_control {}
template rbar_control is _resizable_bar_control {}

/**
   ## Resizable BAR (RBAR) Capability registers

    - name: `rbar_capability`
    - implemented: functional

   The standard PCIe templates for Base Address Registers automatically find
   and use the size configured in instances of this template, when enabled.

   Uses the following parameters:
   * `num_bars`: Number of resizable bars present in this capability.
   * `bar_indexes`: list of integers, setting `init_val` of `control.id` field for each RBAR
   * `bar_capabilities`: list of integers, setting `init_val` of `capability` register for each RBAR
*/
template rbar_capability is _resizable_bar_capability {
    param id = 0x15;
    group bar[i < num_bars] {
        register capability is pcie_desc {
            param pcie_desc = "Resizable BAR Capability";
        }
        register control is (rbar_control, pcie_desc) {
            param pcie_desc = "Resizable BAR Control";
            field id  is pcie_desc {
                param pcie_desc = "BAR Index";
            }
            field num is pcie_desc {
                param pcie_desc = "Number of Resizable BARs";
            }
            field sz  is pcie_desc {
                param pcie_desc = "BAR Size";
            }
            field cap is pcie_desc {
                param pcie_desc = "Resizable BAR Capability";
            }
        }
    }
}

template defining_rbar_capability {
    param rbar_offset;
    param rbar_next_ptr;
    param rbar_num_bars;
    param rbar_indexes;
    param rbar_capabilities;

    group rbar is rbar_capability {
        param base = rbar_offset;
        param next_ptr = rbar_next_ptr;
        param num_bars = rbar_num_bars;
        param bar_indexes = rbar_indexes;
        param bar_capabilities = rbar_capabilities;
    }
}

/**
   ## VF Resizable BAR (VFRBAR) Capability registers

    - name: `vf_rbar_capability`
    - implemented: functional

   This template works just like the Resizable Bar (RBAR) template, but is
   detected and used by the standard PCIe templates for Virtual Function Base
   Address Registers instead.
*/
template vf_rbar_capability is _resizable_bar_capability {
    param id = 0x24;
    group bar[i < num_bars] {
        register capability is pcie_desc {
            param pcie_desc = "VF Resizable BAR Capability";
        }
        register control is (vf_rbar_control, pcie_desc) {
            param pcie_desc = "VF Resizable BAR Control";
            field id  is pcie_desc {
                param pcie_desc = "VF BAR Index";
            }
            field num is pcie_desc {
                param pcie_desc = "Number of VF Resizable BARs";
            }
            field sz  is pcie_desc {
                param pcie_desc = "VF BAR Size";
            }
            field cap is pcie_desc {
                param pcie_desc = "VF Resizable BAR Capability";
            }
        }
    }
}

template defining_vf_rbar_capability {
    param vf_rbar_offset;
    param vf_rbar_next_ptr;
    param vf_rbar_num_bars;
    param vf_rbar_indexes;
    param vf_rbar_capabilities;

    group vf_rbar is vf_rbar_capability {
        param base = vf_rbar_offset;
        param next_ptr = vf_rbar_next_ptr;
        param num_bars = vf_rbar_num_bars;
        param bar_indexes = vf_rbar_indexes;
        param bar_capabilities = vf_rbar_capabilities;
    }
}

/**
   ## Dynamic Power Allocation (DPA) Capability registers

    - name: `dpa_capability`
    - implemented: registers only

   Uses the following parameters:
   * `num_substates`: number of power allocation registers, default 1
*/
template dpa_capability is extended_capability {
    param id = 0x16;
    param num_substates default 1;

    register capability        size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "DPA Capability";
    }
    register latency_indicator size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "DPA Latency Indicator";
    }
    register status            size 2 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "DPA Status";
    }
    register control           size 2 @ (base + 0xe) is pcie_desc {
        param pcie_desc = "DPA Control";
    }
    register power_allocation[i < num_substates] size 1 @ (base + 0x10 + i) is pcie_desc {
            param pcie_desc = "DPA Power Allocation Array";
    }

    register capability {
        field sm  @ [4:0] is pcie_desc {
            param pcie_desc = "Substate Max";
            param init_val default num_substates - 1;
        }
        field tlu   @ [9:8]   is pcie_desc {
            param pcie_desc = "Transition Latency Unit";
        }
        field pas   @ [13:12] is pcie_desc {
            param pcie_desc = "Power Allocation Scale";
        }
        field tlv0  @ [23:16] is pcie_desc {
            param pcie_desc = "Transition Latency Value 0";
        }
        field tlv1  @ [31:24] is pcie_desc {
            param pcie_desc = "Transition Latency Value 1";
        }
    }
    register latency_indicator;
    register status {
        field ss   @ [4:0] is pcie_desc {
            param pcie_desc = "Substate Status";
        }
        field sce  @ [8:8] is pcie_desc {
            param pcie_desc = "Substate Control Enabled";
            param init_val default 0x1;
        }
    }
    register control {
        field sc  @ [4:0] is pcie_desc {
            param pcie_desc = "Substate Control";
        }
    }

#if (use_standard_access_templates) {
    register capability is read_only;
    register latency_indicator is read_only;
    register status {
        field ss is ignore_write;
    }
    register power_allocation[i < num_substates] is read_only;
}
#if (use_standard_write_templates) {
    register status {
        field sce is pcie_write_1_clears;
    }
}
}

template defining_dpa_capability {
    param dpa_offset;
    param dpa_next_ptr;
    param dpa_num_substates default 1;

    group dpa is dpa_capability {
        param base = dpa_offset;
        param next_ptr = dpa_next_ptr;
        param num_substates = dpa_num_substates;
    }
}

/**
   ## Transaction Processing Hints (TPH) Requester Extended Capability registers

    - name: `tph_capability`
    - implemented: registers only

   Uses the following parameters:
   * `num_tables`: number of TPH ST Table registers, default 1
*/
template tph_capability is extended_capability {
    param id = 0x17;
    param num_tables default 1;

    register capability        size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "TPH Requester Capability";
    }
    register control           size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "TPH Requester Control";
    }
#if (num_tables > 0) {
    register st_table[i < num_tables] size 2 @ (base + 0xc + i * 0x2) is pcie_desc {
        param pcie_desc = "TPH ST Table";
    }
}

    register capability {
        field nstms   @ [0:0]   is pcie_desc {
            param pcie_desc = "No ST Mode Supported";
            param init_val default 1;
        }
        field ivms    @ [1:1] is pcie_desc {
            param pcie_desc = "Interrupt Vector Mode Supported";
        }
        field dsms    @ [2:2] is pcie_desc {
            param pcie_desc = "Device Specific Mode Supported";
        }
        field etphrs  @ [8:8] is pcie_desc {
            param pcie_desc = "Extended TPH Requester Supported";
        }
        field sttl    @ [10:9]  is pcie_desc {
            param pcie_desc = "ST Table Location";
            param init_val default num_tables > 0 ? 1 : 0;
        }
        field stts    @ [26:16] is pcie_desc {
            param pcie_desc = "ST Table Size";
            param init_val default num_tables > 0 ? num_tables - 1 : 0;
        }
    }
    register control {
        field stms   @ [2:0] is pcie_desc {
            param pcie_desc = "ST Mode Select";
        }
        field tphre  @ [9:8] is pcie_desc {
            param pcie_desc = "TPH Requester Enable";
        }
    }
#if (num_tables > 0) {
    register st_table[i < num_tables] {
        field stl  @ [7:0]  is pcie_desc {
            param pcie_desc = "ST Lower";
        }
        field stu  @ [15:8] is pcie_desc {
            param pcie_desc = "ST Upper";
        }
    }
}

#if (use_standard_access_templates) {
    register capability is read_only;
}
}

template defining_tph_capability {
    param tph_offset;
    param tph_next_ptr;
    param tph_num_tables default 1;

    group tph is tph_capability {
        param base = tph_offset;
        param next_ptr = tph_next_ptr;
        param num_tables = tph_num_tables;
    }
}

/**
   ## Latency Tolerance Reporting (LTR) Capability registers

    - name: `ltr_capability`
    - implemented: registers only
*/
template ltr_capability is extended_capability {
    param id = 0x18;

    register max_snoop_latency     size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Max Snoop Latency";
    }
    register max_non_snoop_latency size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "Max Non-Snoop Latency";
    }

    register max_snoop_latency {
        field mslv  @ [9:0]   is pcie_desc {
            param pcie_desc = "Max Snoop Latency Value";
        }
        field msls  @ [12:10] is pcie_desc {
            param pcie_desc = "Max Snoop Latency Scale";
        }
    }
    register max_non_snoop_latency {
        field mslv  @ [9:0]   is pcie_desc {
            param pcie_desc = "Max Snoop Latency Value";
        }
        field msls  @ [12:10] is pcie_desc {
            param pcie_desc = "Max Snoop Latency Scale";
        }
    }
#if (use_standard_write_templates) {
    register max_snoop_latency is pcie_no_function_level_reset;
    register max_non_snoop_latency is pcie_no_function_level_reset;
}
}

template defining_ltr_capability {
    param ltr_offset;
    param ltr_next_ptr;

    group ltr is ltr_capability {
        param base = ltr_offset;
        param next_ptr = ltr_next_ptr;
    }
}

/**
   ## Secondary PCI Express (SPE) Capability registers

    - name: `spe_capability`
    - implemented: registers only

   Uses the following parameters:
   * `max_link_width`: number of Equalization Control registers, no default
*/
template spe_capability is extended_capability {
    param id = 0x19;
    param max_link_width;

    register link_control_3    size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Link Control 3";
    }
    register lane_error_status size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Lane Error Status";
    }
    register equalization_control[i < max_link_width] size 2
        @ (base + 0xc + i * 0x2) is pcie_desc {
            param pcie_desc = "Equalization Control Register";
    }

    register link_control_3 {
        field pe     @ [0:0] is pcie_desc {
            param pcie_desc = "Perform Equalization";
        }
        field lerie  @ [1:1] is pcie_desc {
            param pcie_desc = "Link Equalization Request Interrupt Enable";
        }
        field elsogv @ [15:9] is pcie_desc {
            param pcie_desc = "Enable Lower SKP OS Generation Vector";
        }
    }
    register equalization_control[i < max_link_width] {
        field dptp   @ [3:0] is pcie_desc {
            param pcie_desc = "Downstream Port Transmitter Preset";
            param init_val default 0xf;
        }
        field dprph  @ [6:4] is pcie_desc {
            param pcie_desc = "Downstream Port Receiver Preset Hint";
            param init_val default 0x7;
        }
        field uptp   @ [11:8] is pcie_desc {
            param pcie_desc = "Upstream Port Transmitter Preset";
            param init_val default 0xf;
        }
        field uprph  @ [14:12] is pcie_desc {
            param pcie_desc = "Upstream Port Receiver Preset Hint";
            param init_val default 0x7;
        }
    }

#if (use_standard_access_templates) {
    register equalization_control[i < max_link_width] {
        field dptp  is hwinit;
        field dprph is hwinit;
        field uptp  is hwinit;
        field uprph is hwinit;
    }
}
#if (use_standard_write_templates) {
    register link_control_3 {
        field elsogv is pcie_no_function_level_reset;
    }
    register equalization_control[i < max_link_width] {
        field dptp  is pcie_sticky;
        field dprph is pcie_sticky;
        field uptp  is pcie_sticky;
        field uprph is pcie_sticky;
    }
    register lane_error_status is (pcie_write_1_clears, pcie_sticky);
}
}

template defining_spe_capability {
    param spe_offset;
    param spe_next_ptr;
    param spe_max_link_width;

    group spe is spe_capability {
        param base = spe_offset;
        param next_ptr = spe_next_ptr;
        param max_link_width = spe_max_link_width;
    }
}

/**
   ## PASID Extended Capability Structure registers

    - name: `pasid_capability`
    - implemented: functional
*/
template pasid_capability is extended_capability {
    param id = 0x1b;

    register capability        size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "PASID Capability";
    }
    register control           size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "PASID Control";
    }

    register capability {
        field eps @ [1]    is pcie_desc {
            param pcie_desc = "Execute Permission Supported";
        }
        field pms @ [2]    is pcie_desc {
            param pcie_desc = "Privileged Mode Supported";
        }
#if (pcie_version >= 6.0) {
        field trwps @ [3] is pcie_desc {
            param pcie_desc = "Translation Requests with PASID Supported";
        }
}
        field mpw @ [12:8] is pcie_desc {
            param pcie_desc = "Max PASID Width";
        }
    }
    register control {
        field pe  @ [0] is pcie_desc {
            param pcie_desc = "PASID Enable";
        }
        field epe @ [1] is pcie_desc {
            param pcie_desc = "Execute Permission Enable";
        }
        field pme @ [2] is pcie_desc {
            param pcie_desc = "Privileged Mode Enable";
        }
#if (pcie_version >= 6.0) {
        field trwpe @ [3] is pcie_desc {
            param pcie_desc = "Translated Requests with PASID Enable";
        }
}

        field epe {
            method pcie_write(uint64 value) default {
                if (value == 1 && !capability.eps.val) {
                    log spec_viol: "Cannot enable %s because it is not supported: %s=%d",
                        this.qname, capability.eps.qname, capability.eps.val;
                    return;
                }
                this.val = value;
            }
        }
        field pme {
            method pcie_write(uint64 value) default {
                if (value == 1 && !capability.pms.val) {
                    log spec_viol: "Cannot enable %s because it is not supported: %s=%d",
                        this.qname, capability.pms.qname, capability.pms.val;
                    return;
                }
                this.val = value;
            }
        }
#if (pcie_version >= 6.0) {
        field trwpe {
            method pcie_write(uint64 value) default {
                if (value == 1 && !capability.trwps.val) {
                    log spec_viol: "Cannot enable %s because it is not supported: %s=%d",
                        this.qname, capability.trwps.qname, capability.trwps.val;
                    return;
                }
                this.val = value;
            }
        }
}
    }

    /**
       #### verify_pasid(pcie_pasid_info_t pasid) -> (bool)

       Verifies that the `PASID` capability is configured correctly
       to support the contents of the `pasid` argument.
       If the check fails it is considered a modelling error.
       Returns true on success.
    */
    shared method verify_pasid(pcie_pasid_info_t pasid) -> (bool);
    method verify_pasid(pcie_pasid_info_t pasid) -> (bool) default {
        local bool ret = true;
        if (control.pe.val == 0) {
            log error:
                "%s PASID usage while feature disabled: %s",
                this.qname, control.pe.qname;
            ret = false;
        }
        if (pasid.field.exe != 0 && !control.epe.val) {
            log error:
                "%s PASID Execute requested while feature disabled: %s",
                this.qname, control.epe.qname;
            ret = false;
        }
        if (pasid.field.priv != 0 && !control.pme.val) {
            log error:
                "%s PASID Privileged Mode requested while feature disabled: %s",
                this.qname, control.pme.qname;
            ret = false;
        }
        if (pasid.field.pasid > ((1 << capability.mpw.val) - 1)) {
                log error:
                "%s PASID value 0x%x greater than maximum supported value 0x%x",
                this.qname, pasid.field.pasid, (1 << capability.mpw.val) - 1;
            ret = false;
        }
        return ret;
    }
    /**
       #### verify_pasid_with_at(pcie_pasid_info_t pasid, pcie_at_t at) -> (bool)

       Verifies that the `PASID` capability is configured correctly
       to support the contents of the `pasid` argument and the type of argument `at`.
       If the check fails is considered a modelling error.
       Returns true on success.
    */
    shared method verify_pasid_with_at(pcie_pasid_info_t pasid, pcie_at_t at) -> (bool);
    method verify_pasid_with_at(pcie_pasid_info_t pasid, pcie_at_t at) -> (bool) default {
        if (!verify_pasid(pasid))
            return false;

#if (pcie_version >= 6.0) {
        if (at == PCIE_AT_Translated) {
            if (!control.trwpe.val) {
                log error:
                    "%s PASID Translated request while feature disabled: %s",
                    this.qname, control.trwpe.qname;
                return false;
            }
        }
}
        return true;
    }

#if (use_standard_access_templates) {
    register capability is read_only;
}
#if (use_standard_write_templates) {
    register control {
        field epe is pcie_write;
        field pme is pcie_write;
#if (pcie_version >= 6.0) {
        field trwpe is pcie_write;
}
    }
}
}

template defining_pasid_capability {
    param pasid_offset;
    param pasid_next_ptr;

    group pasid is pasid_capability {
        param base = pasid_offset;
        param next_ptr = pasid_next_ptr;
    }
}

/**
   ## LN Requester Extended Capability registers

    - name: `lnr_capability`
    - implemented: registers only
*/
template lnr_capability is extended_capability {
    param id = 0x1c;

    register capability size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "LNR Capability Register";
    }
    register control    size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "LNR Control Register";
    }

    register capability {
        field s64  @ [0]    is pcie_desc {
            param pcie_desc = "LNR-64 Supported";
        }
        field s128 @ [1]    is pcie_desc {
            param pcie_desc = "LNR-128 Supported";
        }
        field max  @ [12:8] is pcie_desc {
            param pcie_desc = "LNR Registration Max";
        }
    }

    register control {
        field en  @ [0]    is pcie_desc {
            param pcie_desc = "LNR Enable";
        }
        field cls @ [1]    is pcie_desc {
            param pcie_desc = "LNR CLS";
        }
        field rl  @ [12:8] is pcie_desc {
            param pcie_desc = "LNR Registration Limit";
        }
    }

#if (use_standard_access_templates) {
    register capability is read_only;
}
}

template defining_lnr_capability {
    param lnr_offset;
    param lnr_next_ptr;

    group lnr is lnr_capability {
        param base = lnr_offset;
        param next_ptr = lnr_next_ptr;
    }
}

/**
   ## Downstream Port Containment (DPC) Extended Capability registers

    - name: `dpc_capability`
    - implemented: registers only

   Uses the following parameters:
   * `root_port`: presence of PIO registers, default false
*/
template dpc_capability is extended_capability {
    param id = 0x1d;
    param root_port default false;

    register capability        size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "DPC Capability";
    }
    register control           size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "DPC Control";
    }
    register status            size 2 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "DPC Status";
    }
    register error_source_id   size 2 @ (base + 0xa) is pcie_desc {
        param pcie_desc = "DPC Error Source ID";
    }

#if (root_port) {
    group pio {
        register status                size 4 @ (base + 0x0c) is pcie_desc {
            param pcie_desc = "PIO Status";
        }
        register mask_id               size 4 @ (base + 0x10) is pcie_desc {
            param pcie_desc = "PIO Mask ID";
        }
        register severity              size 4 @ (base + 0x14) is pcie_desc {
            param pcie_desc = "PIO Severity";
        }
        register syserror              size 4 @ (base + 0x18) is pcie_desc {
            param pcie_desc = "PIO SysError";
        }
        register exception             size 4 @ (base + 0x1c) is pcie_desc {
            param pcie_desc = "PIO Exception";
        }
        register log_impspec           size 4 @ (base + 0x30) is pcie_desc {
            param pcie_desc = "PIO ImpSpec Log";
        }
        register header_log[i < 4]     size 4 @ (base + 0x20 + i * 4) is pcie_desc {
            param pcie_desc = "PIO Header Log";
        }
        register tlp_prefix_log[i < 4] size 4 @ (base + 0x34 + i * 4) is pcie_desc {
            param pcie_desc = "PIO TLP Prefix Log";
        }
    }
}

    register capability {
        field imn   @ [4:0]  is pcie_desc {
            param pcie_desc = "Interrupt Message Number";
        }
        field rpe   @ [5]    is pcie_desc {
            param pcie_desc = "RP Extensions";
            param init_val default root_port #? 1 #: 0;
        }
        field ptebs @ [6]    is pcie_desc {
            param pcie_desc = "Poisoned TLP Egress Blocking Supported";
        }
        field dsts  @ [7]    is pcie_desc {
            param pcie_desc = "DPC Software Triggering Supported";
        }
        field rpls  @ [11:8] is pcie_desc {
            param pcie_desc = "RP PIO Log Size";
        }
        field des  @ [12]    is pcie_desc {
            param pcie_desc = "DL_Active ERR_COR Supported";
        }
    }
    register control {
        field dte   @ [1:0] is pcie_desc {
            param pcie_desc = "DPC Trigger Enable";
        }
        field dcc   @ [2]   is pcie_desc {
            param pcie_desc = "DPC Completion Control";
        }
        field die   @ [3]   is pcie_desc {
            param pcie_desc = "DPC Interrupt Enable";
        }
        field dee   @ [4]   is pcie_desc {
            param pcie_desc = "DPC ERR_COR Enable";
        }
        field ptebe @ [5]   is pcie_desc {
            param pcie_desc = "Poisoned TLP Egress Blocking Enable";
        }
        field dst   @ [6]   is pcie_desc {
            param pcie_desc = "DPC Software Trigger";
        }
        field daee  @ [7]   is pcie_desc {
            param pcie_desc = "DL_Active ERR_COR Enable";
        }
        field dse   @ [8]   is pcie_desc {
            param pcie_desc = "DPC SIG_SFW Enable";
        }
    }
    register status {
        field dts  @ [0]   is pcie_desc {
            param pcie_desc = "DPC Trigger Status";
        }
        field dtr  @ [2:1] is pcie_desc {
            param pcie_desc = "DPC Trigger Reason";
        }
        field dis  @ [3]   is pcie_desc {
            param pcie_desc = "DPC Interrupt Status";
        }
        field drb  @ [4]   is pcie_desc {
            param pcie_desc = "DPC RP Busy";
        }
        field dtre @ [6:5] is pcie_desc {
            param pcie_desc = "DPC Trigger Reason Extension";
        }
        field rpfp @ [12:8] is pcie_desc {
            param pcie_desc = "RP PIO First Error Pointer";
        }
        field dss  @ [13]   is pcie_desc {
            param pcie_desc = "DPC SIG_SFW Status";
        }
    }

#if (use_standard_access_templates) {
    register capability is read_only;
    register error_source_id is (read_only);
    register status {
        field dtr  is ignore_write;
        field drb  is ignore_write;
        field dtre is ignore_write;
        field rpfp is ignore_write;
    }

#if (root_port) {
    group pio {
        register log_impspec           is (ignore_write);
        register header_log[i < 4]     is (ignore_write);
        register tlp_prefix_log[i < 4] is (ignore_write);
    }
}
}
#if (use_standard_write_templates) {
    register status     is pcie_sticky;
    register error_source_id is (pcie_sticky);
    register status is pcie_sticky {
        field dts  is pcie_write_1_clears;
        field dis  is pcie_write_1_clears;
        field dss  is pcie_write_1_clears;
    }

#if (root_port) {
    group pio {
        register status                is (pcie_write_1_clears, pcie_sticky);
        register mask_id               is pcie_sticky;
        register severity              is pcie_sticky;
        register syserror              is pcie_sticky;
        register exception             is pcie_sticky;
        register log_impspec           is (pcie_sticky);
        register header_log[i < 4]     is (pcie_sticky);
        register tlp_prefix_log[i < 4] is (pcie_sticky);
    }
}
}
}

template defining_dpc_capability {
    param dpc_offset;
    param dpc_next_ptr;
    param dpc_root_port default false;

    group dpc is dpc_capability {
        param base = dpc_offset;
        param next_ptr = dpc_next_ptr;
        param root_port = dpc_root_port;
    }
}

/**
   ## L1 PM Substates Extended Capability registers

    - name: `l1pms_capability`
    - implemented: registers only

   Fields to be added upon request.
*/
template l1pms_capability is extended_capability {
    param id = 0x1e;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "L1 PM Substates Capabilities";
    }
    register control1   size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "L1 PM Substates Control 1";
    }
    register control2   size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "L1 PM Substates Control 2";
    }
    register status     size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "L1 PM Substates Status";
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
}
#if (use_standard_write_templates) {
    /* Shall not be reseted on FLR according to spec if MUST@FLT is
     * set otherwise it is strongly recommended.
     */
    register capability is pcie_no_function_level_reset;
    register control1 is pcie_no_function_level_reset;
    register control2 is pcie_no_function_level_reset;
    register status is pcie_no_function_level_reset;

    register capability is pcie_sticky;
    register status     is pcie_write_1_clears;
}
}

template defining_l1pms_capability {
    param l1pms_offset;
    param l1pms_next_ptr;

    group l1pms is l1pms_capability {
        param base = l1pms_offset;
        param next_ptr = l1pms_next_ptr;
    }
}

/**
   ## Precision Time Management (PTM) Capability registers

    - name: `ptm_capability`
    - implemented: registers only

    Fields to be added upon request
*/
template ptm_capability is extended_capability {
    param id = 0x1f;

    register capability size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "PTM Capabilities Register";
    }
    register control    size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "PTM Control Register";
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register control is pcie_no_function_level_reset;

    register capability is pcie_sticky;
}
}

template defining_ptm_capability {
    param ptm_offset;
    param ptm_next_ptr;

    group ptm is ptm_capability {
        param base = ptm_offset;
        param next_ptr = ptm_next_ptr;
    }
}

/**
   ## M-PCIe Extended Capability registers

    - name: `mpcie_capability`
    - implemented: registers only
*/
template mpcie_capability is extended_capability {
    param id = 0x20;

    register capability        size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "M-PCIe Capabilities";
    }
    register control           size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "M-PCIe Control";
    }
    register status            size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "M-PCIe Status";
    }
    register lane_error_status size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "M-PCIe LANE Error Status";
    }
    register phy_control_addr  size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "M-PCIe Phy Control Address";
    }
    register phy_control_data  size 4 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "M-PCIe Phy Control Data";
    }
}

template defining_mpcie_capability {
    param mpcie_offset;
    param mpcie_next_ptr;

    group mpcie is mpcie_capability {
        param base = mpcie_offset;
        param next_ptr = mpcie_next_ptr;
    }
}

/**
   ## FRS Queueing Extended Capability registers

    - name: `frsq_capability`
    - implemented: registers only

   Fields to be added upon request
*/
template frsq_capability is extended_capability {
    param id = 0x21;

    register capability    size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "FRS Queueing Capabilities";
    }
    register status        size 2 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "FRS Queueing Status";
    }
    register control       size 2 @ (base + 0xa) is pcie_desc {
        param pcie_desc = "FRS Queueing Control";
    }
    register message_queue size 4 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "FRS Message Queue";
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
    register message_queue is read_only;
}
#if (use_standard_write_templates) {
    register capability is pcie_sticky;
    register status is pcie_write_1_clears;
}
}

template defining_frsq_capability {
    param frsq_offset;
    param frsq_next_ptr;

    group frsq is frsq_capability {
        param base = frsq_offset;
        param next_ptr = frsq_next_ptr;
    }
}

/**
   ## Readiness Time Reporting Extended Capability registers

    - name: `rtr_capability`
    - implemented: registers only

   Fields to be added upon request
*/
template rtr_capability is extended_capability {
    param id = 0x22;

    register reg_1 size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Readiness Time Reporting Register 1";
    }
    register reg_2 size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Readiness Time Reporting Register 2";
    }

#if (use_standard_access_templates) {
    register reg_1 is hwinit;
    register reg_2 is hwinit;
}
#if (use_standard_write_templates) {
    register reg_1 is pcie_sticky;
    register reg_2 is pcie_sticky;
}
}

template defining_rtr_capability {
    param rtr_offset;
    param rtr_next_ptr;

    group rtr is rtr_capability {
        param base = rtr_offset;
        param next_ptr = rtr_next_ptr;
    }
}

/**
   ## Data Link Feature Extended Capability registers

    - name: `dlf_capability`
    - implemented: registers only
*/
template dlf_capability is extended_capability {
    param id = 0x25;

    register capability size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "DLF Capabilities";
    }
    register status     size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "DLF Status";
    }

    register capability {
        field ldlfs @ [22:0] is pcie_desc {
            param pcie_desc = "Local Data Link Feature Supported";
        }
        field dlfee @ [31:31] is pcie_desc {
            param pcie_desc = "Data Link Feature Exchange Enable";
        }
    }
    register status {
        field rdlfs  @ [22:0] is pcie_desc {
            param pcie_desc = "Remote Data Link Feature Supported";
        }
        field rdlfsv @ [31:31] is pcie_desc {
            param pcie_desc = "Remote Data Link Feature Supported Valid";
        }
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
    register status is read_only;
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register status     is pcie_no_function_level_reset;

    register capability is pcie_sticky;
}
}

template defining_dlf_capability {
    param dlf_offset;
    param dlf_next_ptr;

    group dlf is dlf_capability {
        param base = dlf_offset;
        param next_ptr = dlf_next_ptr;
    }
}

/**
   ## Physical Layer 16.0 GT/s Extended Capability registers

    - name: `pl16g_capability`
    - implemented: registers only

   Uses the following parameters:
   * `max_link_width`: maximum link width, no default
   * `max_lanes`: maximum number of lanes, no default
*/
template pl16g_capability is extended_capability {
    param id = 0x26;
    param max_link_width;
    param max_lanes;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "16.0 GT/s Capabilities";
    }
    register control    size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "16.0 GT/s Control";
    }
    register status     size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "16.0 GT/s Status";
    }
    register ldpms      size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "16.0 GT/s Local Data Parity Mismatch Status";
    }
    register frdpms     size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "16.0 GT/s First Retimer Data Parity Mismatch Status";
    }
    register srdpms     size 4 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "16.0 GT/s Second Retimer Data Parity Mismatch Status";
    }
    register reserved   size 4 @ (base + 0x1c) is pcie_desc {
        param pcie_desc = "16.0 GT/s Reserved";
    }
    register lec[i < (max_lanes - 1) / 4 + 1] size 4 @ (base + i * 4 + 0x20) is pcie_desc {
        param pcie_desc = "16.0 GT/s Lane Equalization Control";
    }

    register status {
        field ec   @ [0:0] is pcie_desc {
            param pcie_desc = "Equalization 16.0 GT/s Complete";
        }
        field ep1s @ [1:1] is pcie_desc {
            param pcie_desc = "Equalization 16.0 GT/s Phase 1 Successful";
        }
        field ep2s @ [2:2] is pcie_desc {
            param pcie_desc = "Equalization 16.0 GT/s Phase 2 Successful";
        }
        field ep3s @ [3:3] is pcie_desc {
            param pcie_desc = "Equalization 16.0 GT/s Phase 3 Successful";
        }
        field ler  @ [4:4] is pcie_desc {
            param pcie_desc = "Link Equalization Request 16.0 GT/s";
        }
    }
    register ldpms {
        field status @ [max_link_width - 1:0] is pcie_desc {
            param pcie_desc = "Local Data Parity Mismatch Status";
        }
    }
    register frdpms {
        field status @ [max_link_width - 1:0] is pcie_desc {
            param pcie_desc = "First Retimer Data Parity Mismatch Status";
        }
    }
    register srdpms {
        field status @ [max_link_width - 1:0] is pcie_desc {
            param pcie_desc = "Second Retimer Data Parity Mismatch Status";
        }
    }
    register lec[i < (max_lanes - 1) / 4 + 1] {
        // fields to be added upon request
        param init_val default 0xffffffff;
    }

#if (use_standard_access_templates) {
    register status {
        field ec   is ignore_write;
        field ep1s is ignore_write;
        field ep2s is ignore_write;
        field ep3s is ignore_write;
    }
    register lec[i < ...] is hwinit;
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register control is pcie_no_function_level_reset;
    register status is pcie_no_function_level_reset;
    register ldpms is pcie_no_function_level_reset;
    register frdpms is pcie_no_function_level_reset;
    register srdpms is pcie_no_function_level_reset;
    register reserved is pcie_no_function_level_reset;
    register lec[i < ...] is pcie_no_function_level_reset;

    register status is pcie_sticky {
        field ler  is pcie_write_1_clears;
    }
    register ldpms {
        field status is (pcie_sticky, pcie_write_1_clears);
    }
    register frdpms {
        field status is (pcie_sticky, pcie_write_1_clears);
    }
    register srdpms {
        field status is (pcie_sticky, pcie_write_1_clears);
    }
}
}

template defining_pl16g_capability {
    param pl16g_offset;
    param pl16g_next_ptr;
    param pl16g_max_link_width;
    param pl16g_max_lanes;

    group pl16g is pl16g_capability {
        param base = pl16g_offset;
        param next_ptr = pl16g_next_ptr;
        param max_link_width = pl16g_max_link_width;
        param max_lanes = pl16g_max_lanes;
    }
}

/**
   ## Lane Margining at the Receiver Extended Capability registers

    - name: `lmar_capability`
    - implemented: registers only

   Uses the following parameters:
   * `max_lanes`: number of lane control and status registers, no default
*/
template lmar_capability is extended_capability {
    param id = 0x27;
    param max_lanes;

    register port_capabilities size 2 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Margining Port Capabilities";
    }
    register port_status       size 2 @ (base + 0x6) is pcie_desc {
        param pcie_desc = "Margining Port Status";
    }
    register lane_control[i < max_lanes] size 2 @ (base + i * 4 + 0x8) is pcie_desc {
        param pcie_desc = "Margining Lane Control";
    }
    register lane_status[i < max_lanes]  size 2 @ (base + i * 4 + 0xa) is pcie_desc {
        param pcie_desc = "Margining Lane Status";
    }

    register port_capabilities {
        field muds @ [0:0] is pcie_desc {
            param pcie_desc = "Margining uses Driver Software";
        }
    }
    register port_status {
        field mr  @ [0:0] is pcie_desc {
            param pcie_desc = "Margining Ready";
        }
        field msr @ [1:1] is pcie_desc {
            param pcie_desc = "Margining Software Ready";
        }
    }
    register lane_control[i < max_lanes] {
        field rn @ [2:0]  is pcie_desc {
            param pcie_desc = "Receiver Number";
        }
        field mt @ [5:3]  is pcie_desc {
            param pcie_desc = "Margin Type";
        }
        field um @ [6:6]  is pcie_desc {
            param pcie_desc = "Usage Model";
        }
        field mp @ [15:8] is pcie_desc {
            param pcie_desc = "Margin Payload";
        }
    }
    register lane_status[i < max_lanes] {
        field rns @ [2:0] is pcie_desc {
            param pcie_desc = "Receiver Number Status";
        }
        field mts @ [5:3] is pcie_desc {
            param pcie_desc = "Margin Type Status";
        }
        field ums @ [6:6] is pcie_desc {
            param pcie_desc = "Usage Model Status";
        }
        field mps @ [15:8] is pcie_desc {
            param pcie_desc = "Margin Payload Status";
        }
    }

#if (use_standard_access_templates) {
    register port_capabilities is hwinit;
    register port_status is read_only;
    register lane_status[i < max_lanes] is read_only;
}
#if (use_standard_write_templates) {
    register port_capabilities is pcie_no_function_level_reset;
    register port_status is pcie_no_function_level_reset;
    register lane_control[i < ...] is pcie_no_function_level_reset;
    register lane_status[i < ...] is pcie_no_function_level_reset;

    register port_capabilities is pcie_sticky;
}
}

template defining_lmar_capability {
    param lmar_offset;
    param lmar_next_ptr;
    param lmar_max_lanes;

    group lmar is lmar_capability {
        param base = lmar_offset;
        param next_ptr = lmar_next_ptr;
        param max_lanes = lmar_max_lanes;
    }
}

/**
   ## Physical Layer 32.0 GT/s Extended Capability registers

    - name: `pl32g_capability`
    - implemented: registers only

   Uses the following parameters:
   * `max_link_width`: maximum link width, no default
   * `max_lanes`: maximum number of lanes, no default
*/
template pl32g_capability is extended_capability {
    param id = 0x2a;
    param max_lanes;

    register capability size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "32.0 GT/s Capabilities";
    }
    register control    size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "32.0 GT/s Control";
    }
    register status     size 4 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "32.0 GT/s Status";
    }
    register rmtsd1     size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "Received Modified TS Data 1";
    }
    register rmtsd2     size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "Received Modified TS Data 2";
    }
    register tmtsd1     size 4 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "Transmitted Modified TS Data 1";
    }
    register tmtsd2     size 4 @ (base + 0x1c) is pcie_desc {
        param pcie_desc = "Transmitted Modified TS Data 2";
    }
    register lec[i < (max_lanes - 1) / 4 + 1] size 4 @ (base + i * 4 + 0x20) is pcie_desc {
        param pcie_desc = "32.0 GT/s Lane Equalization Control";
    }

    register capability   {
        field ebthrs  @ [0:0] is pcie_desc {
            param pcie_desc = "Equalization bypass to highest rate Supported";
        }
        field nens    @ [1:1] is pcie_desc {
            param pcie_desc = "No Equalization Needed Supported";
        }
        field mtsum0s @ [8:8] is pcie_desc {
            param pcie_desc = "Modified TS Usage Mode 0 Supported - PCI Express";
        }
        field mtsum1s @ [9:9] is pcie_desc {
            param pcie_desc = "Modified TS Usage Mode 1 Supported - Training Set Message";
        }
        field mtsum2s @ [10:10] is pcie_desc {
            param pcie_desc = "Modified TS Usage Mode 2 Supported - Alternate Protocol";
        }
        field mtsrum  @ [15:11] is pcie_desc {
            param pcie_desc = "Modified TS Reserved Usage Modes";
        }
    }
    register control {
        field ebthrd @ [0:0] is pcie_desc {
            param pcie_desc = "Equalization bypass to highest rate Disable";
        }
        field nend   @ [1:1] is pcie_desc {
            param pcie_desc = "No Equalization Needed Disable";
        }
        field mtsums @ [10:8] is pcie_desc {
            param pcie_desc = "Modified TS Usage Mode Selected";
        }
    }
    register status {
        field ec    @ [0:0] is pcie_desc {
            param pcie_desc = "Equalization 32.0 GT/s Complete";
        }
        field ep1s  @ [1:1] is pcie_desc {
            param pcie_desc = "Equalization 32.0 GT/s Phase 1 Successful";
        }
        field ep2s  @ [2:2] is pcie_desc {
            param pcie_desc = "Equalization 32.0 GT/s Phase 2 Successful";
        }
        field ep3s  @ [3:3] is pcie_desc {
            param pcie_desc = "Equalization 32.0 GT/s Phase 3 Successful";
        }
        field ler   @ [4:4] is pcie_desc {
            param pcie_desc = "Link Equalization Request 32.0 GT/s";
        }
        field mtsr  @ [5:5] is pcie_desc {
            param pcie_desc = "Modified TS Received";
        }
        field relbc @ [7:6] is pcie_desc {
            param pcie_desc = "Received Enhanced Link Behavior Control";
        }
        field tpo   @ [8:8] is pcie_desc {
            param pcie_desc = "Transmitter Precoding On";
        }
        field tpr   @ [9:9] is pcie_desc {
            param pcie_desc = "Transmitter Precode Request";
        }
        field nenr @ [10:10] is pcie_desc {
            param pcie_desc = "No Equalization Needed Received";
        }
    }
    register rmtsd1 {
        field rmtsum @ [2:0] is pcie_desc {
            param pcie_desc = "Received Modified TS Usage Mode";
        }
        field rmtsi1 @ [15:3] is pcie_desc {
            param pcie_desc = "Received Modified TS Information 1";
        }
        field rmtsvid @ [31:16] is pcie_desc {
            param pcie_desc = "Received Modified TS Vendor ID";
        }
    }
    register rmtsd2 {
        field rmtsi2 @ [23:0] is pcie_desc {
            param pcie_desc = "Received Modified TS Information 2";
        }
        field apns @ [25:24] is pcie_desc {
            param pcie_desc = "Alternate Protocol Negotiation Status";
        }
    }
    register tmtsd1 {
        field tmtsum @ [2:0] is pcie_desc {
            param pcie_desc = "Transmitted Modified TS Usage Mode";
        }
        field tmtsi1 @ [15:3] is pcie_desc {
            param pcie_desc = "Transmitted Modified TS Information 1";
        }
        field tmtsvid @ [31:16] is pcie_desc {
            param pcie_desc = "Transmitted Modified TS Vendor ID";
        }
    }
    register tmtsd2 {
        field tmtsi2 @ [23:0] is pcie_desc {
            param pcie_desc = "Transmitted Modified TS Information 2";
        }
        field apns @ [25:24] is pcie_desc {
            param pcie_desc = "Alternate Protocol Negotiation Status";
        }
    }
    register lec[i < (max_lanes - 1) / 4 + 1] {
        // fields to be added upon request
        param init_val default 0xffffffff;
    }

#if (use_standard_access_templates) {
    register capability {
        field ebthrs  is hwinit;
        field nens    is hwinit;
        field mtsum0s is ignore_write;
        field mtsum1s is hwinit;
        field mtsum2s is hwinit;
        field mtsrum  is ignore_write;
    }
    register status {
        field ec    is (read_only);
        field ep1s  is (read_only);
        field ep2s  is (read_only);
        field ep3s  is (read_only);
        field ler   is (read_only);
        field mtsr  is (read_only);
        field relbc is (read_only);
        field tpo   is (read_only);
        field tpr   is (read_only);
        field nenr  is (read_only);
    }
    register rmtsd1 is read_only;
    register rmtsd2 is read_only;
    register tmtsd1 is read_only;
    register tmtsd2 is read_only;
    register lec[i < (max_lanes - 1) / 4 + 1] is hwinit;
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register control is pcie_no_function_level_reset;
    register status is pcie_no_function_level_reset;
    register rmtsd1 is pcie_no_function_level_reset;
    register rmtsd2 is pcie_no_function_level_reset;
    register tmtsd1 is pcie_no_function_level_reset;
    register tmtsd2 is pcie_no_function_level_reset;
    register lec[i < ...] is pcie_no_function_level_reset;

    register capability {
        field ebthrs  is pcie_sticky;
        field nens    is pcie_sticky;
        field mtsum1s is pcie_sticky;
        field mtsum2s is pcie_sticky;
    }
    register control is pcie_sticky;
    register status {
        field ec    is (pcie_sticky);
        field ep1s  is (pcie_sticky);
        field ep2s  is (pcie_sticky);
        field ep3s  is (pcie_sticky);
        field ler   is (pcie_sticky);
    }
}
}

template defining_pl32g_capability {
    param pl32g_offset;
    param pl32g_next_ptr;
    param pl32g_max_lanes;

    group pl32g is pl32g_capability {
        param base = pl32g_offset;
        param next_ptr = pl32g_next_ptr;
        param max_lanes = pl32g_max_lanes;
    }
}

/**
   ## Physical Layer 64.0 GT/s Extended Capability registers

    - name: `pl64g_capability`
    - implemented: registers only

   Uses the following parameters:
   * `max_link_width`: maximum link width, no default
   * `max_lanes`: maximum number of lanes, no default
*/
template pl64g_capability is extended_capability {
    param id = 0x31;
    param max_lanes;

    register capability size 4 @ (base + 0x4)  is pcie_desc {
        param pcie_desc = "64.0 GT/s Capabilities";
    }
    register control    size 4 @ (base + 0x8)  is pcie_desc {
        param pcie_desc = "64.0 GT/s Control";
    }
    register status     size 4 @ (base + 0xc)  is pcie_desc {
        param pcie_desc = "64.0 GT/s Status";
    }
    register lec[i < (max_lanes - 1) / 4 + 1] size 4 @ (base + i * 4 + 0x20) is pcie_desc {
        param pcie_desc = "64.0 GT/s Lane Equalization Control";
    }

    register status {
        field ec   @ [0:0] is pcie_desc {
            param pcie_desc = "Equalization 64.0 GT/s Complete";
        }
        field ep1s @ [1:1] is pcie_desc {
            param pcie_desc = "Equalization 64.0 GT/s Phase 1 Successful";
        }
        field ep2s @ [2:2] is pcie_desc {
            param pcie_desc = "Equalization 64.0 GT/s Phase 2 Successful";
        }
        field ep3s @ [3:3] is pcie_desc {
            param pcie_desc = "Equalization 64.0 GT/s Phase 3 Successful";
        }
        field ler  @ [4:4] is pcie_desc {
            param pcie_desc = "Link Equalization Request 64.0 GT/s";
        }
        field tpo  @ [5:5] is pcie_desc {
            param pcie_desc = "Transmitter Precoding On";
        }
        field tpr  @ [6:6] is pcie_desc {
            param pcie_desc = "Transmitter Precode Request";
        }
        field nenr @ [7:7] is pcie_desc {
            param pcie_desc = "No Equalization Needed Received";
        }
    }
    register lec[i < (max_lanes - 1) / 4 + 1] {
        // fields to be added upon request
        param init_val default 0xffffffff;
    }

#if (use_standard_access_templates) {
    register status {
        field ec    is (read_only);
        field ep1s  is (read_only);
        field ep2s  is (read_only);
        field ep3s  is (read_only);
        field ler   is (read_only);
        field tpo   is (read_only);
        field tpr   is (read_only);
        field nenr  is (read_only);
    }
    register lec[i < (max_lanes - 1) / 4 + 1] is hwinit;
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register control is pcie_no_function_level_reset;
    register status is pcie_no_function_level_reset;
    register lec[i < ...] is pcie_no_function_level_reset;

    register control is pcie_sticky;
    register status {
        field ec    is (pcie_sticky);
        field ep1s  is (pcie_sticky);
        field ep2s  is (pcie_sticky);
        field ep3s  is (pcie_sticky);
        field ler   is (pcie_sticky);
    }
}
}

template defining_pl64g_capability {
    param pl64g_offset;
    param pl64g_next_ptr;
    param pl64g_max_lanes;

    group pl64g is pl64g_capability {
        param base = pl64g_offset;
        param next_ptr = pl64g_next_ptr;
        param max_lanes = pl64g_max_lanes;
    }
}

/**
   ## Designated Vendor-Specific Extended Capability (DVSEC) registers

    - name: `dvsec_capability`
    - implemented: registers only
*/
template dvsec_capability is extended_capability {
    param id = 0x23;

    register header size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "Vendor-Specific Header";
        field id  @ [15:0]  is pcie_desc {
            param pcie_desc = "ID";
        }
        field rev @ [19:16] is pcie_desc {
            param pcie_desc = "Revision";
        }
        field len @ [31:20] is pcie_desc {
            param pcie_desc = "Length";
        }
    }

#if (pcie_version >= 5.0) {
    register header_2 size 2 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "Vendor-Specific Header 2";
        field id @ [15:0] is pcie_desc {
            param pcie_desc = "DVSEC ID";
        }
    }
}

#if (use_standard_access_templates) {
    register header is read_only;
#if (pcie_version >= 5.0) {
    register header_2 is read_only;
}
}
}

template defining_dvsec_capability {
    param dvsec_offset;
    param dvsec_next_ptr;

    group dvsec is dvsec_capability {
        param base = dvsec_offset;
        param next_ptr = dvsec_next_ptr;
    }
}

/**
   ## Hierarchy ID Extended Capability registers

    - name: `hid_capability`
    - implemented: registers only
*/
template hid_capability is extended_capability {
    param id = 0x28;

    register status        size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "Header ID Status";
    }
    register data          size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "Hierarchy ID Data";
    }
    register system_guid_1 size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "Hierarchy ID System GUID 1";
    }
    register system_guid_2 size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "Hierarchy ID System GUID 2";
    }
    register system_guid_3 size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "Hierarchy ID System GUID 3";
    }
    register system_guid_4 size 4 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "Hierarchy ID System GUID 4";
    }
    register system_guid_5 size 4 @ (base + 0x1c) is pcie_desc {
        param pcie_desc = "Hierarchy ID System GUID 5";
    }

    register status {
        field mrid @ [15:0] is pcie_desc {
            param pcie_desc = "Message Requester ID";
        }
        field hidw @ [28]   is pcie_desc {
            param pcie_desc = "Hierarchy ID Writable";
        }
        field hidc @ [29]   is pcie_desc {
            param pcie_desc = "Hierarchy ID VF Configurable";
        }
        field hidp @ [30]   is pcie_desc {
            param pcie_desc = "Hierarchy ID Pending";
        }
        field hidv @ [31]   is pcie_desc {
            param pcie_desc = "Hierarchy ID Valid";
        }
    }

    register data {
        field sgaid @ [7:0]   is pcie_desc {
            param pcie_desc = "System GUID Authority ID";
        }
        field hid   @ [31:16] is pcie_desc {
            param pcie_desc = "Hierarchy ID";
        }
    }

#if (use_standard_access_templates) {
    register status {
        field mrid is read_only;
        field hidc is read_only;
    }
}
}

template defining_hid_capability {
    param hid_offset;
    param hid_next_ptr;

    group hid is hid_capability {
        param base = hid_offset;
        param next_ptr = hid_next_ptr;
    }
}

/**
   ## Native PCIe Enclosure Management (NPEM) Extended Capability registers

    - name: `npem_capability`
    - implemented: registers only
*/
template npem_capability is extended_capability {
    param id = 0x29;

    register capability size 4 @ (base + 0x4) is pcie_desc {
        param pcie_desc = "NPEM Capability";
    }
    register control    size 4 @ (base + 0x8) is pcie_desc {
        param pcie_desc = "NPEM Control";
    }
    register status     size 4 @ (base + 0xc) is pcie_desc {
        param pcie_desc = "NPEM Status";
    }

    register capability {
        field nc     @ [0]  is pcie_desc {
            param pcie_desc = "NPEM capable";
        }
        field nrstc  @ [1]  is pcie_desc {
            param pcie_desc = "NPEM Reset capable";
        }
        field nokc   @ [2]  is pcie_desc {
            param pcie_desc = "NPEM OK state capable";
        }
        field nlc    @ [3]  is pcie_desc {
            param pcie_desc = "NPEM Locate state capable";
        }
        field nfc    @ [4]  is pcie_desc {
            param pcie_desc = "NPEM Fail state capable";
        }
        field nrc    @ [5]  is pcie_desc {
            param pcie_desc = "NPEM Rebuild state capable";
        }
        field npc    @ [6]  is pcie_desc {
            param pcie_desc = "NPEM PFA state capable";
        }
        field nhsc   @ [7]  is pcie_desc {
            param pcie_desc = "NPEM Hot Spare state capable";
        }
        field ncac   @ [8]  is pcie_desc {
            param pcie_desc = "NPEM In A Critical Array state capable";
        }
        field nfac   @ [9]  is pcie_desc {
            param pcie_desc = "NPEM In A Failed Array state capable";
        }
        field nidc   @ [10] is pcie_desc {
            param pcie_desc = "NPEM_Invalid_ Device_Type state capable";
        }
        field ndc    @ [11] is pcie_desc {
            param pcie_desc = "NPEM_Disabled state capable";
        }
    }

    register control {
        field ne     @ [0]  is pcie_desc {
            param pcie_desc = "NPEM enable";
        }
        field nrste  @ [1]  is pcie_desc {
            param pcie_desc = "NPEM Reset enable";
        }
        field noke   @ [2]  is pcie_desc {
            param pcie_desc = "NPEM OK state enable";
        }
        field nle    @ [3]  is pcie_desc {
            param pcie_desc = "NPEM Locate state enable";
        }
        field nfe    @ [4]  is pcie_desc {
            param pcie_desc = "NPEM Fail state enable";
        }
        field nre    @ [5]  is pcie_desc {
            param pcie_desc = "NPEM Rebuild state enable";
        }
        field npe    @ [6]  is pcie_desc {
            param pcie_desc = "NPEM PFA state enable";
        }
        field nhse   @ [7]  is pcie_desc {
            param pcie_desc = "NPEM Hot Spare state enable";
        }
        field ncae   @ [8]  is pcie_desc {
            param pcie_desc = "NPEM In A Critical Array state enable";
        }
        field nfae   @ [9]  is pcie_desc {
            param pcie_desc = "NPEM In A Failed Array state enable";
        }
        field nide   @ [10] is pcie_desc {
            param pcie_desc = "NPEM_Invalid_ Device_Type state enable";
        }
        field nde    @ [11] is pcie_desc {
            param pcie_desc = "NPEM_Disabled state enable";
        }
    }

    register status {
        field ncc @ [0] is pcie_desc {
            param pcie_desc = "NPEM Command Completed";
        }
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
    register status is ones;
}
}

template defining_npem_capability {
    param npem_offset;
    param npem_next_ptr;

    group npem is npem_capability {
        param base = npem_offset;
        param next_ptr = npem_next_ptr;
    }
}

/**
   ## Alternate Protocol Extended Capability registers

    - name: `ap_capability`
    - implemented: registers only

   Fields to be added upon request
*/
template ap_capability is extended_capability {
    param id = 0x2b;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "AP Capabilities";
    }
    register control    size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "AP Control";
    }
    register data1      size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "AP Data 1";
    }
    register data2      size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "AP Data 2";
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
    register data1 is read_only;
    register data2 is read_only;
}
#if (use_standard_write_templates) {
    register capability is pcie_sticky;
}
}

template defining_ap_capability {
    param ap_offset;
    param ap_next_ptr;

    group ap is ap_capability {
        param base = ap_offset;
        param next_ptr = ap_next_ptr;
    }
}

/**
   ## System Firmware Intermediary (SFI) Extended Capability registers

   <div id=sfi_capability class=register />

   Fields and access restrictions to be added upon request
*/
template sfi_capability is extended_capability {
    param id = 0x2c;

    register capability  size 2 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "SFI Capability";
    }
    register control     size 2 @ (base + 0x06) is pcie_desc {
        param pcie_desc = "SFI Control";
    }
    register status      size 2 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "SFI Status";
    }
    register cam_address size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "SFI CAM Address";
    }
    register cam_data    size 2 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "SFI CAM Data";
    }

}

template defining_sfi_capability {
    param sfi_offset;
    param sfi_next_ptr;

    group sfi is sfi_capability {
        param base = sfi_offset;
        param next_ptr = sfi_next_ptr;
    }
}

/**
   ## Single Root I/O Virtualization (SR-IOV) Extended Capability registers

    - name: `sriov_capability`
    - implemented: functional

   This is a partially functional template; users must implement the methods
   `get_offset` and `get_stride`, create an array of DML-objects that simulate
   the configuration header for each virtual function, and add instances of the
   `vf_base_address` template for each VF BAR that is implemented by the
   physical function.

   Uses the following parameters:

   * `virtual_functions`: A sequence of `vf_type_0_bank` objects simulating the
                          virtual functions.

*/
template sriov_capability is (extended_capability, init) {
    param id = 0x10;
    param virtual_functions: sequence(vf_type_0_bank);
    param function : uint16;  // internal, for now
    param function default bank.function;
    param each_vf_bar: sequence(vf_base_address);
    param each_vf_bar = each vf_base_address in (this);


    method init() default {
        foreach vf in (virtual_functions) {
            vf.set_physical_function(cast(bank, type_0_bank));
        }
    }

    register capability      size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "SR-IOV Capability";
    }
    register control         size 2 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "SR-IOV Control";
    }
    register status          size 2 @ (base + 0x0a) is pcie_desc {
        param pcie_desc = "SR-IOV Status";
    }
    register initial_vfs     size 2 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "SR-IOV Initial VFs";
    }
    register total_vfs       size 2 @ (base + 0x0e) is pcie_desc {
        param pcie_desc = "SR-IOV Total VFs";
    }
    register num_vfs         size 2 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "SR-IOV Number of VFs";
    }
    register func_dep_link   size 1 @ (base + 0x12) is pcie_desc {
        param pcie_desc = "SR-IOV Function Dependency Link";
    }
    register first_vf_offset size 2 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "SR-IOV First VF Offset";
    }
    register vf_stride       size 2 @ (base + 0x16) is pcie_desc {
        param pcie_desc = "SR-IOV VF Stride";
    }
    register vf_device_id    size 2 @ (base + 0x1a) is pcie_desc {
        param pcie_desc = "SR-IOV VF Device ID";
    }

    register supported_page_sizes size 4 @ (base + 0x1c) is pcie_desc {
        param pcie_desc = "SR-IOV Supported Page Sizes";
    }
    register system_page_size     size 4 @ (base + 0x20) is pcie_desc {
        param pcie_desc = "SR-IOV System Page Size";
    }
    register vf_migration_state_offset size 4 @ (base + 0x3c) is pcie_desc {
        param pcie_desc = "SR-IOV VF Migration State Array Offset";
    }

    register capability {
        field vfmc     @ [0] is pcie_desc {
            param pcie_desc = "VF Migration Capable";
        }
        field arichp   @ [1] is pcie_desc {
            param pcie_desc = "ARI Capable Hierarchy Preserved";
        }
        field vf10btrs @ [2] is pcie_desc {
            param pcie_desc = "VF 10-bit Tag Requester Supported";
        }
#if (pcie_version >= 6.0) {
        field vf14btrs @ [3] is pcie_desc {
            param pcie_desc = "VF 14-bit Tag Requester Supported";
        }
}
        field vfmimn   @ [31:21] is pcie_desc {
            param pcie_desc = "VF Migration Interrupt Message Number";
        }
#if (pcie_version >= 6.0) {
        // These fields are deprecated in PCIE 6 and onwards
        field vfmc { param init_val = 0; }
        field vfmimn { param init_val = 0; }
}
    }

    register control {
        field vfe   @ [0] is pcie_desc {
            param pcie_desc = "VF Enable";
            method pcie_write(uint64 value) {
                if (this.val != value) {
                    this.val = value;
                    update_virtual_functions();
                }
            }
        }
        field vfme  @ [1] is pcie_desc {
            param pcie_desc = "VF Migration Enable";
        }
        field vfmie @ [2] is pcie_desc {
            param pcie_desc = "VF Migration Interrupt Enable";
        }
        field vfmse @ [3] is pcie_desc {
            param pcie_desc = "VF Memory Space Enable";
            method pcie_write(uint64 value) {
                if (this.val != value) {
                    this.val = value;
                    update_virtual_bars();
                }
            }
        }
        field arich @ [4] is pcie_desc {
            param pcie_desc = "ARI Capable Hierarchy";
            method pcie_write(uint64 value) {
                local uint16 devid = get_device_id();
                foreach pf in (each sriov_capability in (bank.parent)) {
                    /* only the lowest-numbered function with an SR-IOV
                       capability structure accepts writes to arich, in all
                       other functions this bit is hardwired to 0 */
                    if (pf.get_device_id() < devid)
                        return;
                }
                if (this.val != value) {
                    if (control.vfe.val) {
                        log spec_viol: "%s may only be written when %s is 0",
                            qname, control.vfe.qname;
                        return;
                    }
                    this.val = value;
                }
            }
        }
        field vf10btre @ [5] is pcie_desc {
            param pcie_desc = "VF 10-bit Tag Requester Enable";
        }
#if (pcie_version >= 6.0) {
        field vf14btre @ [6] is pcie_desc {
            param pcie_desc = "VF 14-bit Tag Requester Enable";
        }
}
    }

    register status {
        field vfms  @ [0] is pcie_desc {
            param pcie_desc = "VF Migration Status";
        }
    }

    register initial_vfs {
        param init_val default virtual_functions.len;
    }

    register total_vfs {
        param init_val default virtual_functions.len;
    }

    register num_vfs {
        method pcie_write(uint64 value) {
            if (control.vfe.val) {
                log spec_viol: "%s may only be written when %s is 0",
                    qname, control.vfe.qname;
                return;
            }
            if (value > total_vfs.val) {
                log spec_viol: "%s written (%d) is greater than %s (%d)",
                    qname, value, total_vfs.qname, total_vfs.val;
            }
            if (value > virtual_functions.len) {
                log error: "%s written (%d) is greater than VFs modeled (%d)",
                    qname, value, virtual_functions.len;
            }
            this.val = value;
        }
    }

    register first_vf_offset {
        param configuration default "pseudo";
        method pcie_read() -> (uint64) {
            return get_offset();
        }
    }

    register vf_stride {
        param configuration default "pseudo";
        method pcie_read() -> (uint64) {
            return get_stride();
        }
    }
    register vf_device_id {
        param init_val default bank.device_id.init_val;
    }

    register supported_page_sizes {
        /* PFs are required to support 4KB, 8KB, 64KB, 256KB, 1MB, and 4MB */
        param init_val default 0b10101010011;
    }

    register system_page_size {
        param init_val default 1;
        method pcie_write(uint64 value) {
            if (control.vfe.val) {
                log spec_viol: "%s may only be written when %s is 0",
                    qname, control.vfe.qname;
                return;
            }
            if ((value & supported_page_sizes.val) == 0) {
                log spec_viol: "unsupported value for %s: 0x%x", qname, value;
                return;
            }
            if (value == 0 || !is_power_of_2(value)) {
                log spec_viol: "invalid value for %s: 0x%x", qname, value;
                return;
            }
            this.val = value;
        }
    }
    /**
       ### Methods

       * `get_offset() -> (uint16)`

         Returns the offset to the first virtual function, must be implemented
         by the user.

    */
    method get_offset() -> (uint16) default {
        error "SR-IOV models must implement get_offset()";
        return 0;
    }

    independent startup memoized method get_virtual_functions()
        -> (const vf_type_0_bank *) {
        local vf_type_0_bank *vfs = new vf_type_0_bank[virtual_functions.len + 1];
        foreach p in (virtual_functions) {
            if ((p.vf_number == 0) || (p.vf_number > virtual_functions.len))
                assert false;
            vfs[p.vf_number] = p;
        }
        return vfs;
    }

    /**
       * `get_stride() -> (uint16)`

         Returns the stride between virtual functions, must be implemented by
         the user.

    */
    method get_stride() -> (uint16) default {
        error "SR-IOV models must implement get_stride()";
        return 0;
    }

    method update_virtual_functions() default {
        for (local int i = 1; i <= virtual_functions.len; i++) {
            try {
                local vf_type_0_bank vf = get_virtual_functions()[i];
                vf.del_function();
            } catch {
                log error: "Could not retrieve virtual function number %d", i;
                return;
            }
        }
        if (control.vfe.val) {
            local uint16 rid = get_device_id() + get_offset();
            local uint16 cnt =
                num_vfs.val < virtual_functions.len ?
                num_vfs.val : virtual_functions.len;
            log info: "updating %d virtual functions", cnt;
            for (local int i = 1; i <= cnt; i++) {
                try {
                    local vf_type_0_bank vf = get_virtual_functions()[i];
                    vf.update_function(rid);
                } catch {
                    log error: "Could not retrieve virtual function number %d", i;
                    return;
                }
                rid += get_stride();
            }
        }
        update_virtual_bars();
    }

    method update_virtual_bars() default {
        foreach b in (each vf_base_address in (this.parent))
            b.update_map();
    }

    shared method get_device_id() -> (uint16);
    method get_device_id() -> (uint16) {
        return bank.get_device_id();
    }

#if (use_standard_access_templates) {
    register capability {
        field vfmc is read_only;
        field arichp is read_only;
        field vf10btrs is hwinit;
#if (pcie_version >= 6.0) {
        field vf14btrs is hwinit;
}
        field vfmimn is read_only;
    }

    register initial_vfs is hwinit;
    register total_vfs is hwinit;
    register func_dep_link is read_only;
    register first_vf_offset is (read_only);
    register vf_stride is (read_only);
    register vf_device_id is read_only;
    register supported_page_sizes is read_only;
    register vf_migration_state_offset is read_only;
}
#if (use_standard_write_templates) {
    register capability {
        field vf10btrs is pcie_sticky;
    }
    register control {
        field vfe is pcie_write;
        field vfme is unimpl;
        field vfmie is unimpl;
        field vfmse is pcie_write;
        field arich is pcie_write;
    }

    register initial_vfs is pcie_sticky;
    register total_vfs is pcie_sticky;
    register num_vfs is pcie_write;
    register first_vf_offset is (pcie_read);
    register vf_stride is (pcie_read);
    register system_page_size is pcie_write;
}
}

template defining_sriov_capability {
    param sriov_offset;
    param sriov_next_ptr;
    param sriov_virtual_functions;

    group sriov is sriov_capability {
        param base = sriov_offset;
        param next_ptr = sriov_next_ptr;
        param virtual_functions = sriov_virtual_functions;
    }
}

/**
   ## Device 3 Extended Capability registers

    - name: `dev3_capability`
    - implemented: registers only
*/
template dev3_capability is extended_capability {
    param id = 0x2f;

    register capabilities size 4 @ (base + 0x04);
    register control      size 4 @ (base + 0x08);
    register status       size 4 @ (base + 0x0c);

    register capabilities is pcie_desc {
        param pcie_desc = "Dev3 Capabilities";
        field drrs @ [0:0] is pcie_desc {
            param pcie_desc = "DMWr Request Routing Supported";
        }
        field btcs @ [1:1] is pcie_desc {
            param pcie_desc = "14-Bit Tag Completer Supported";
        }
        field btrs @ [2:2] is pcie_desc {
            param pcie_desc = "14-Bit Tag Requester Supported";
        }
        field rls  @ [3:3] is pcie_desc {
            param pcie_desc = "Receiver L0p Supported";
        }
        field plel @ [6:4] is pcie_desc {
            param pcie_desc = "Port L0p Exit Latency";
        }
        field rlel @ [9:7] is pcie_desc {
            param pcie_desc = "Retimer L0p Exit Latency";
        }
    }
    register control is pcie_desc {
        param pcie_desc = "Dev3 Control";
        field dre  @ [0:0] is pcie_desc {
            param pcie_desc = "DMWr Requester Enable";
        }
        field deb  @ [1:1] is pcie_desc {
            param pcie_desc = "DMWr Egress Blocking";
        }
        field tre  @ [2:2] is pcie_desc {
            param pcie_desc = "14-Bit Tag Requester Enable";
        }
        field le   @ [3:3] is pcie_desc {
            param pcie_desc = "L0p Enable";
        }
        field tlw  @ [6:4] is pcie_desc {
            param pcie_desc = "Target Link Width";
        }
    }
    register status is pcie_desc {
        param pcie_desc = "Dev3 Status";
        field ilw @ [2:0] is pcie_desc {
            param pcie_desc = "Initial Link Width";
        }
        field sc  @ [3:3] is pcie_desc {
            param pcie_desc = "Segment Captured";
        }
        field rls @ [4:4] is pcie_desc {
            param pcie_desc = "Remote L0p Supported";
        }
    }

    shared method set_captured_segment_id(bool valid, uint8 value);
    shared method get_captured_segment_id() -> (bool, uint8);

    method set_captured_segment_id(bool valid, uint8 value) default {
        segment.valid = valid;
        segment.captured_id = value;
    }
    method get_captured_segment_id() -> (bool, uint8) default {
        return (segment.valid, segment.captured_id);
    }
    group segment {
        saved bool valid;
        saved uint8 captured_id;
    }

    register status {
        field sc is (pcie_read) {
            method pcie_read() -> (uint64) default {
                local (bool valid, uint8 segment) = get_captured_segment_id();
                return valid ? 1 : 0;
            }
        }
    }

#if (use_standard_access_templates) {
    register capabilities is hwinit;
    register status is read_only;
}
}

template defining_dev3_capability {
    param dev3_offset;
    param dev3_next_ptr;

    group dev3 is dev3_capability {
        param base = dev3_offset;
        param next_ptr = dev3_next_ptr;
    }
}

/**
   ## Flit Logging Extended Capability registers

    - name: `fl_capability`
    - implemented: registers only
*/
template fl_capability is extended_capability {
    param id = 0x32;

    register fel1 size 4   @ (base + 0x04) is pcie_desc {
        param pcie_desc = "Flit Error Log 1";
    }
    register fel2 size 4   @ (base + 0x08) is pcie_desc {
        param pcie_desc = "Flit Error Log 2";
    }
    register fecc  size 2  @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "Flit Error Counter Control";
    }
    register fecs  size 2  @ (base + 0x0e) is pcie_desc {
        param pcie_desc = "Flit Error Counter Status";
    }
    register fber_ms[i < 10] size 4 @ (base + (0x10 + i * 4)) is pcie_desc {
        param pcie_desc = "FBER Measurement Status";
    }

    register fel1 {
        field felv     @ [0:0] is pcie_desc {
            param pcie_desc = "Flit Error Log Valid";
        }
        field felw     @ [3:1] is pcie_desc {
            param pcie_desc = "Flit Error Link Width";
        }
        field follfe   @ [7:4] is pcie_desc {
            param pcie_desc = "Flit Offset from the Last Logged Flit in Error";
        }
        field cfelfe   @ [12:8] is pcie_desc {
            param pcie_desc = "Consecutive Flit Error after the Last Flit Error";
        }
        field mefelrv  @ [13:13] is pcie_desc {
            param pcie_desc = "More Entries for Flit Error Log Register are Valid";
        }
        field uf       @ [14:14] is pcie_desc {
            param pcie_desc = "Unrecognized Flit";
        }
        field fuef     @ [15:15] is pcie_desc {
            param pcie_desc = "FEC Uncorrectable Error in Flit";
        }
        field speg_0   @ [23:16] is pcie_desc {
            param pcie_desc = "Syndrome Parity for ECC Group 0";
        }
        field sceg_0   @ [31:24] is pcie_desc {
            param pcie_desc = "Syndrome Check for ECC Group 0";
        }
    }
    register fel2 {
        field speg_1  @ [7:0] is pcie_desc {
            param pcie_desc = "Syndrome Parity for ECC Group 1";
        }
        field sceg_1  @ [15:8] is pcie_desc {
            param pcie_desc = "Syndrome Check for ECC Group 1";
        }
        field speg_2  @ [23:16] is pcie_desc {
            param pcie_desc = "Syndrome Parity for ECC Group 0";
        }
        field sceg_2  @ [31:24] is pcie_desc {
            param pcie_desc = "Syndrome Check for ECC Group 0";
        }
    }
    register fecc {
        field fece  @ [0:0] is pcie_desc {
            param pcie_desc = "Flit Error Counter Enable";
        }
        field etc   @ [3:2] is pcie_desc {
            param pcie_desc = "Events to count";
        }
        field teec  @ [11:4] is pcie_desc {
            param pcie_desc = "Trigger Event on Error Count";
        }
    }
    register fecs {
        field fece   @ [2:0] is pcie_desc {
            param pcie_desc = "Link Width when Error Counter Started";
        }
        field igtec  @ [3:3] is pcie_desc {
            param pcie_desc = "Interrupt Generated based on Trigger Event Count";
        }
        field fec    @ [15:8] is pcie_desc {
            param pcie_desc = "Flit Error Counter";
        }
    }
    register fber_ms[i < 10] {
        field fme    @ [0:0] is pcie_desc {
            param pcie_desc = "FBER Measurement Enable";
        }
        field cfc    @ [1:1] is pcie_desc {
            param pcie_desc = "Clear FBER Counters";
        }
        field ge     @ [3:2] is pcie_desc {
            param pcie_desc = "Granularity of per-Lane Error reported";
        }
        field rlbfb  @ [4:4] is pcie_desc {
            param pcie_desc = "Report Longest Burst vs First Burst";
        }
    }

#if (use_standard_access_templates) {
    register fel1 {
        field felw     is (read_only);
        field follfe   is (read_only);
        field cfelfe   is (read_only);
        field mefelrv  is (read_only);
        field uf       is (read_only);
        field fuef     is (read_only);
        field speg_0   is (read_only);
        field sceg_0   is (read_only);
    }

    register fel2 {
        field speg_1  is (read_only);
        field sceg_1  is (read_only);
        field speg_2  is (read_only);
        field sceg_2  is (read_only);
    }
    register fecs {
        field fece  is (read_only);
        field fec   is (read_only);
    }
}
#if (use_standard_write_templates) {
    register fel1 is pcie_no_function_level_reset;
    register fel2 is pcie_no_function_level_reset;
    register fecc is pcie_no_function_level_reset;
    register fecs is pcie_no_function_level_reset;
    register fber_ms[i < ...] is pcie_no_function_level_reset;

    register fel1 {
        field felv     is (pcie_sticky, pcie_write_1_clears);
        field felw     is (pcie_sticky);
        field follfe   is (pcie_sticky);
        field cfelfe   is (pcie_sticky);
        field mefelrv  is (pcie_sticky);
        field uf       is (pcie_sticky);
        field fuef     is (pcie_sticky);
        field speg_0   is (pcie_sticky);
        field sceg_0   is (pcie_sticky);
    }
    register fel2 {
        field speg_1  is (pcie_sticky);
        field sceg_1  is (pcie_sticky);
        field speg_2  is (pcie_sticky);
        field sceg_2  is (pcie_sticky);
    }
    register fecs {
        field fece   is (pcie_sticky);
        field igtec  is (pcie_sticky, pcie_write_1_clears);
        field fec    is (pcie_sticky);
    }
}
}

template defining_fl_capability {
    param fl_offset;
    param fl_next_ptr;

    group fl is fl_capability {
        param base = fl_offset;
        param next_ptr = fl_next_ptr;
    }
}

/**
   ## Flit Performance Measurement Extended Capability registers

    - name: `fpm_capability`
    - implemented: registers only

   Uses the following parameters:
   * `n_lpms`: Number of LTSSM Performance Measurement Status Registers, no default
*/
template fpm_capability is extended_capability {
    param id = 0x33;
    param n_lpms;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "Flit Performance Measurement Capability";
    }
    register control    size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "Flit Performance Measurement Control";
    }
    register status     size 4 @ ( base + 0x0C) is pcie_desc {
        param pcie_desc = "Flit Performance Measurement Status";
    }
    register lpms[i < n_lpms] size 4 @ (base + (0x10 + i * 4)) is pcie_desc {
        param pcie_desc = "LTSSM Performance Measurement Status Register";
    }

    register capability {
        field fpic @ [9:0] is pcie_desc {
            param pcie_desc = "Flit Performance Interrupt Vector";
        }
        field ltrc @ [12:10] is pcie_desc {
            param pcie_desc = "LTSSM Tracking Register Count";
        }
    }
    register control {
        field flme    @ [0:0] is pcie_desc {
            param pcie_desc = "Flit Latency Measurement Enable";
        }
        field frt     @ [3:1] is pcie_desc {
            param pcie_desc = "Flit Response Type";
        }
        field ftbm    @ [5:4] is pcie_desc {
            param pcie_desc = "Flit Type being measured";
        }
        field nit     @ [10:6] is pcie_desc {
            param pcie_desc = "Number of instances to track";
        }
        field ife     @ [13:11] is pcie_desc {
            param pcie_desc = "Interrupt if delay for any tracked Flit exceeds this encoded value";
        }
        field lstt    @ [18:14] is pcie_desc {
            param pcie_desc = "LTSSM State Transition Tracker";
        }
        field nl      @ [23:19] is pcie_desc {
            param pcie_desc = "Number of instances to track for LTSSM transition";
        }
        field ilstt1  @ [26:24] is pcie_desc {
            param pcie_desc = "Interrupt if any of the events covered by the low 3 bits of LTSSM State Transition Tracker";
        }
        field ilstt2  @ [29:27] is pcie_desc {
            param pcie_desc = "Interrupt if any of the events covered by low 2 bits of LTSSM State Transition Tracker";
        }
    }
    register status {
        field flts  @ [1:0] is pcie_desc {
            param pcie_desc = "Flit Latency Tracking Status";
        }
        field flt   @ [6:2] is pcie_desc {
            param pcie_desc = "Flit Latency Tracking";
        }
        field igbte @ [7:7] is pcie_desc {
            param pcie_desc = "Interrupt generated based on trigger event";
        }
        field lsttc @ [23:8] is pcie_desc {
            param pcie_desc = "LTSSM State Transition Tracking Counter";
        }
    }
    register lpms[i < n_lpms] {
        field lstts @ [1:0] is pcie_desc {
            param pcie_desc = "LTSSM State Transition Tracking Status";
        }
        field lstt  @ [6:2] is pcie_desc {
            param pcie_desc = "LTSSM State Transition Tracking";
        }
        field ilstt @ [7:7] is pcie_desc {
            param pcie_desc = "Interrupt generated based on trigger event count due to LTSSM State Transition Tracking";
        }
        field lsttc @ [23:8] is pcie_desc {
            param pcie_desc = "LTSSM State Transition Tracking Counter";
        }
    }

#if (use_standard_access_templates) {
    register capability {
        field fpic is (hwinit);
        field ltrc is (hwinit);
    }
    register status {
        field flts  is (read_only);
        field flt   is (read_only);
        field lsttc is (read_only);
    }
    register lpms[i < n_lpms] {
        field lstts is (read_only);
        field lstt  is (read_only);
        field lsttc is (read_only);

    }
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register control    is pcie_no_function_level_reset;
    register status     is pcie_no_function_level_reset;
    register lpms[i < ...] is pcie_no_function_level_reset;

    register status {
        field igbte is (pcie_write_1_clears);
    }
    register lpms[i < n_lpms] {
        field lstts is (pcie_sticky);
        field lstt  is (pcie_sticky);
        field ilstt is (pcie_sticky, pcie_write_1_clears);
        field lsttc is (pcie_sticky);
    }
}
}

template defining_fpm_capability {
    param fpm_offset;
    param fpm_next_ptr;
    param fpm_n_lpms;

    group fpm is fpm_capability {
        param base = fpm_offset;
        param next_ptr = fpm_next_ptr;
        param n_lpms = fpm_n_lpms;
    }
}

/**
   ## Flit Error Injection Extended Capability registers

    - name: `fei_capability`
    - implemented: registers only
*/
template fei_capability is extended_capability {
    param id = 0x34;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "Error Injection Capability";
    }
    register control1   size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "Flit Error Injection Control 1";
    }
    register control2   size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "Flit Error Injection Control 2";
    }
    register status     size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "Flit Error Injection Status";
    }
    register oseic1     size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "Ordered Set Error Injection Control 1";
    }
    register oseic2     size 4 @ (base + 0x18) is pcie_desc {
        param pcie_desc = "Ordered Set Error Injection Control 2";
    }
    register osetis     size 4 @ (base + 0x1c) is pcie_desc {
        param pcie_desc = "Ordered Set Error Tx Injection Status";
    }
    register oseris     size 4 @ (base + 0x20) is pcie_desc {
        param pcie_desc = "Ordered Set Error Rx Injection Status";
    }

    register control1 {
        field feie   @ [0:0] is pcie_desc {
            param pcie_desc = "Flit Error Injection Enable";
        }
        field ietf   @ [1:1] is pcie_desc {
            param pcie_desc = "Inject Errors on Transmitted Flits";
        }
        field ierf   @ [2:2] is pcie_desc {
            param pcie_desc = "Inject Errors on Received Flits";
        }
        field feiedr @ [15:3] is pcie_desc {
            param pcie_desc = "Flit Error Injection Enable Data Rate";
        }
        field nei    @ [20:16] is pcie_desc {
            param pcie_desc = "Number of Errors Injected";
        }
        field sbie   @ [28:21] is pcie_desc {
            param pcie_desc = "Spacing Between Injected Errors";
        }
        field ift    @ [31:29] is pcie_desc {
            param pcie_desc = "Injection on Flit Type";
        }
    }
    register control2 {
        field cei  @ [2:0] is pcie_desc {
            param pcie_desc = "Consecutive Error Injection ";
        }
        field etbi @ [4:3] is pcie_desc {
            param pcie_desc = "Error Type Being Injected";
        }
        field eof  @ [11:5] is pcie_desc {
            param pcie_desc = "Error Offset within Flit";
        }
        field em   @ [19:12] is pcie_desc {
            param pcie_desc = "Error Magnitude";
        }
    }
    register status {
        field fetis @ [1:0] is pcie_desc {
            param pcie_desc = "Flit Error Tx Injection Status";
        }
        field feris @ [3:2] is pcie_desc {
            param pcie_desc = "Flit Error Rx Injection Status";
        }
    }
    register oseic1 {
        field oseie       @ [0:0] is pcie_desc {
            param pcie_desc = "Ordered Set Error Injection Enable";
        }
        field ietos       @ [1:1] is pcie_desc {
            param pcie_desc = "Inject Errors on Transmitted Ordered Sets";
        }
        field ieros       @ [2:2] is pcie_desc {
            param pcie_desc = "Inject Errors on Received Ordered Sets";
        }
        field nei         @ [7:3] is pcie_desc {
            param pcie_desc = "Number of Errors injected";
        }
        field sbie        @ [15:8] is pcie_desc {
            param pcie_desc = "Spacing Between Injected Errors";
        }
        field iet0o       @ [16:16] is pcie_desc {
            param pcie_desc = "Inject Error on TS0 OS";
        }
        field iet1o       @ [17:17] is pcie_desc {
            param pcie_desc = "Inject Error on TS1 OS";
        }
        field iet2o       @ [18:18] is pcie_desc {
            param pcie_desc = "Inject Error on TS2 OS";
        }
        field iet_skp_o   @ [19:19] is pcie_desc {
            param pcie_desc = "Inject Error on SKP OS";
        }
        field iet_eieos_o @ [20:20] is pcie_desc {
            param pcie_desc = "Inject Error on EIEOS OS";
        }
        field iet_eios_o  @ [21:21] is pcie_desc {
            param pcie_desc = "Inject Error on EIOS OS";
        }
        field iet_sds_o   @ [22:22] is pcie_desc {
            param pcie_desc = "Inject Error on SDS OS";
        }
        field ieps        @ [23:23] is pcie_desc {
            param pcie_desc = "Inject Error in Polling State";
        }
        field iecs        @ [24:24] is pcie_desc {
            param pcie_desc = "Inject Error in Configuration State";
        }
        field iels        @ [25:25] is pcie_desc {
            param pcie_desc = "Inject Error in L0 state";
        }
        field ienrs       @ [26:26] is pcie_desc {
            param pcie_desc = "Inject Error in non-EQ Recovery state";
        }
        field ierep01     @ [27:27] is pcie_desc {
            param pcie_desc = "Inject Error in Recovery.Equalization Phase 0 and 1";
        }
        field ierep2      @ [28:28] is pcie_desc {
            param pcie_desc = "Inject Error in Recovery.Equalization Phase 2";
        }
        field ierep3      @ [29:29] is pcie_desc {
            param pcie_desc = "Inject Error in Recovery.Equalization Phase 3";
        }
    }
    register oseic2 {
        field eib  @ [15:0] is pcie_desc {
            param pcie_desc = "Error Injection Bytes";
        }
        field lnei @ [31:16] is pcie_desc {
            param pcie_desc = "Lane Number for Error Injection";
        }
    }
    register osetis {
        field tist0o       @ [1:0] is pcie_desc {
            param pcie_desc = "Tx Injection Status TS0 OS";
        }
        field tist1o       @ [3:3] is pcie_desc {
            param pcie_desc = "Tx Injection Status TS1 OS";
        }
        field tist2o       @ [5:4] is pcie_desc {
            param pcie_desc = "Tx Injection Status TS2 OS";
        }
        field tist_skp_o   @ [7:6] is pcie_desc {
            param pcie_desc = "Tx Injection Status SKP OS";
        }
        field tist_eieos_o @ [9:8] is pcie_desc {
            param pcie_desc = "Tx Injection Status EIEOS OS";
        }
        field tist_eios_o  @ [11:10] is pcie_desc {
            param pcie_desc = "Tx Injection Status EIOS OS";
        }
        field tist_sds_o   @ [13:12] is pcie_desc {
            param pcie_desc = "Tx Injection Status SDS OS";
        }
        field tisps        @ [15:14] is pcie_desc {
            param pcie_desc = "Tx Injection Status Polling";
        }
        field tiscs        @ [17:16] is pcie_desc {
            param pcie_desc = "Tx Injection Status Configuration";
        }
        field tisls        @ [19:18] is pcie_desc {
            param pcie_desc = "Tx Injection Status L0";
        }
        field tisnrs       @ [21:20] is pcie_desc {
            param pcie_desc = "Tx Injection Status non-EQ Recovery";
        }
        field tisrep01     @ [23:22] is pcie_desc {
            param pcie_desc = "Tx Injection Status Recovery.Equalization Phase 0 and 1";
        }
        field tisrep2      @ [25:24] is pcie_desc {
            param pcie_desc = "Tx Injection Status Recovery.Equalization Phase 2";
        }
        field tisrep3      @ [27:26] is pcie_desc {
            param pcie_desc = "Tx Injection Status Recovery.Equalization Phase 3";
        }
    }
    register oseris {
        field rist0o       @ [1:0] is pcie_desc {
            param pcie_desc = "Rx Injection Status TS0 OS";
        }
        field rist1o       @ [3:3] is pcie_desc {
            param pcie_desc = "Rx Injection Status TS1 OS";
        }
        field rist2o       @ [5:4] is pcie_desc {
            param pcie_desc = "Rx Injection Status TS2 OS";
        }
        field rist_skp_o   @ [7:6] is pcie_desc {
            param pcie_desc = "Rx Injection Status SKP OS";
        }
        field rist_eieos_o @ [9:8] is pcie_desc {
            param pcie_desc = "Rx Injection Status EIEOS OS";
        }
        field rist_eios_o  @ [11:10] is pcie_desc {
            param pcie_desc = "Rx Injection Status EIOS OS";
        }
        field rist_sds_o   @ [13:12] is pcie_desc {
            param pcie_desc = "Rx Injection Status SDS OS";
        }
        field risps        @ [15:14] is pcie_desc {
            param pcie_desc = "Rx Injection Status Polling";
        }
        field riscs        @ [17:16] is pcie_desc {
            param pcie_desc = "Rx Injection Status Configuration";
        }
        field risls        @ [19:18] is pcie_desc {
            param pcie_desc = "Rx Injection Status L0";
        }
        field risnrs       @ [21:20] is pcie_desc {
            param pcie_desc = "Rx Injection Status non-EQ Recovery";
        }
        field risrep01     @ [23:22] is pcie_desc {
            param pcie_desc = "Rx Injection Status Recovery.Equalization Phase 0 and 1";
        }
        field risrep2      @ [25:24] is pcie_desc {
            param pcie_desc = "Rx Injection Status Recovery.Equalization Phase 2";
        }
        field risrep3      @ [27:26] is pcie_desc {
            param pcie_desc = "Rx Injection Status Recovery.Equalization Phase 3";
        }
    }

#if (use_standard_access_templates) {
    register control1 {
        field nei is (read_only);
        field ift is (read_only);
    }
    register status {
        field fetis is (read_only);
        field feris is (read_only);
    }
    register osetis {
        field tist0o       is (read_only);
        field tist1o       is (read_only);
        field tist2o       is (read_only);
        field tist_skp_o   is (read_only);
        field tist_eieos_o is (read_only);
        field tist_eios_o  is (read_only);
        field tist_sds_o   is (read_only);
        field tisps        is (read_only);
        field tiscs        is (read_only);
        field tisls        is (read_only);
        field tisnrs       is (read_only);
        field tisrep01     is (read_only);
        field tisrep2      is (read_only);
        field tisrep3      is (read_only);
    }
    register oseris {
        field rist0o       is (read_only);
        field rist1o       is (read_only);
        field rist2o       is (read_only);
        field rist_skp_o   is (read_only);
        field rist_eieos_o is (read_only);
        field rist_eios_o  is (read_only);
        field rist_sds_o   is (read_only);
        field risps        is (read_only);
        field riscs        is (read_only);
        field risls        is (read_only);
        field risnrs       is (read_only);
        field risrep01     is (read_only);
        field risrep2      is (read_only);
        field risrep3      is (read_only);
    }
}
#if (use_standard_write_templates) {
    register capability is pcie_no_function_level_reset;
    register control1 is pcie_no_function_level_reset;
    register control2 is pcie_no_function_level_reset;
    register status is pcie_no_function_level_reset;
    register oseic1 is pcie_no_function_level_reset;
    register oseic2 is pcie_no_function_level_reset;
    register osetis is pcie_no_function_level_reset;
    register oseris is pcie_no_function_level_reset;

    register control1 {
        field nei is (pcie_sticky);
        field ift is (pcie_sticky);
    }
    register oseic1 {
        field oseie       is (pcie_sticky);
        field ietos       is (pcie_sticky);
        field ieros       is (pcie_sticky);
        field nei         is (pcie_sticky);
        field sbie        is (pcie_sticky);
        field iet0o       is (pcie_sticky);
        field iet1o       is (pcie_sticky);
        field iet2o       is (pcie_sticky);
        field iet_skp_o   is (pcie_sticky);
        field iet_eieos_o is (pcie_sticky);
        field iet_eios_o  is (pcie_sticky);
        field iet_sds_o   is (pcie_sticky);
        field ieps        is (pcie_sticky);
        field iecs        is (pcie_sticky);
        field iels        is (pcie_sticky);
        field ienrs       is (pcie_sticky);
        field ierep01     is (pcie_sticky);
        field ierep2      is (pcie_sticky);
        field ierep3      is (pcie_sticky);
    }
    register oseic2 {
        field eib  is (pcie_sticky);
        field lnei is (pcie_sticky);
    }
    register osetis {
        field tist1o       is (pcie_sticky);
        field tist2o       is (pcie_sticky);
        field tist_skp_o   is (pcie_sticky);
        field tist_eieos_o is (pcie_sticky);
        field tist_eios_o  is (pcie_sticky);
        field tist_sds_o   is (pcie_sticky);
        field tisps        is (pcie_sticky);
        field tiscs        is (pcie_sticky);
        field tisls        is (pcie_sticky);
        field tist0o       is (pcie_sticky);
        field tisnrs       is (pcie_sticky);
        field tisrep01     is (pcie_sticky);
        field tisrep2      is (pcie_sticky);
        field tisrep3      is (pcie_sticky);
    }
    register oseris {
        field rist1o       is (pcie_sticky);
        field rist2o       is (pcie_sticky);
        field rist_skp_o   is (pcie_sticky);
        field rist_eieos_o is (pcie_sticky);
        field rist_eios_o  is (pcie_sticky);
        field rist_sds_o   is (pcie_sticky);
        field risps        is (pcie_sticky);
        field riscs        is (pcie_sticky);
        field risls        is (pcie_sticky);
        field rist0o       is (pcie_sticky);
        field risnrs       is (pcie_sticky);
        field risrep01     is (pcie_sticky);
        field risrep2      is (pcie_sticky);
        field risrep3      is (pcie_sticky);
    }
}
}

template defining_fei_capability {
    param fei_offset;
    param fei_next_ptr;

    group fei is fei_capability {
        param base = fei_offset;
        param next_ptr = fei_next_ptr;
    }
}

/**
   ## Shadow Functions Extended Capability registers

    - name: `sf_capability`
    - implemented: registers only

   Uses the following parameters:
   * `n_sfi`: Number of Shadow Functions Instance Registers, no default
*/
template sf_capability is extended_capability {
    param id = 0x2d;
    param n_sfi;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "Shadow Functions Capability";
    }
    register control    size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "Shadow Functions Control";
    }
    register sfi[i < n_sfi] size 4 @ (base + (0x0c + i * 4)) is pcie_desc {
        param pcie_desc = "Shadow Functions Instance N";
    }

    register capability {
        field nsf @ [7:0] is pcie_desc {
            param pcie_desc = "Number of Shadow Functions";
        }
    }
    register control {
        field sfe @ [0:0] is pcie_desc {
            param pcie_desc = "Shadow Functions Enable";
        }
    }
    register sfi[i < n_sfi] {
        field sfn @ [15:0] is pcie_desc {
            param pcie_desc = "Shadow Function Number";
        }
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
    register sfi[i < n_sfi] is hwinit;
}
}

template defining_sf_capability {
    param sf_offset;
    param sf_next_ptr;
    param sf_n_sfi;

    group sf is sf_capability {
        param base = sf_offset;
        param next_ptr = sf_next_ptr;
        param n_sfi = sf_n_sfi;
    }
}

/**
   ## Data Object Exchange Extended Capability registers

    - name: `doe_capability`
    - implemented: functional

   Uses the following parameters:
   * `mailbox_len`: Length of request and response mailbox
   * `interrupt_support`: Use interrupts for DOE related events
*/
template doe_capability is extended_capability {
    param mailbox_len: uint18;    // Length expressed in number of DWORDS
    param interrupt_support: bool;

    param id = 0x2e;
    param supported_protocols = each doe_protocol in (protocols);

#if (mailbox_len < 3) {
    error "Write mailbox length must be at least 3 to support the Data Object"
        + " Exchange Discovery Protocol";
}
    group protocols {
        group discovery is doe_discovery { }
    }

    independent startup memoized method protocol_array()
        -> (const doe_protocol *) {
        local doe_protocol *array = new doe_protocol[supported_protocols.len];
        array[0] = cast(protocols.discovery, doe_protocol);
        local uint8 i = 1;
        foreach p in (supported_protocols) {
            if (p != cast(protocols.discovery, doe_protocol))
                array[i++] = p;
        }
        return array;
    }

    group r_mailbox is doe_mailbox { param length = mailbox_len; }
    group w_mailbox is doe_mailbox { param length = mailbox_len; }

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "DOE Capabilities";
    }
    register control    size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "DOE Control";
    }
    register status     size 4 @ (base + 0x0c) is pcie_desc {
        param pcie_desc = "DOE Status";
    }
    register wdm        size 4 @ (base + 0x10) is pcie_desc {
        param pcie_desc = "DOE Write Data Mailbox";
    }
    register rdm        size 4 @ (base + 0x14) is pcie_desc {
        param pcie_desc = "DOE Read Data Mailbox";
    }

    register capability {
        field dis @ [0:0] is pcie_desc {
            param pcie_desc = "DOE Interrupt Support";
        }
        field dimn @ [11:1] is pcie_desc {
            param pcie_desc = "DOE Interrupt Message Number";
        }
    }
    register control {
        field da  @ [0:0] is pcie_desc {
            param pcie_desc = "DOE Abort";
        }
        field die @ [1:1] is pcie_desc {
            param pcie_desc = "DOE Interrupt Enable";
        }
        field dg  @ [31:31] is pcie_desc {
            param pcie_desc = "DOE Go";
        }
    }
    register status {
        field db  @ [0:0] is pcie_desc {
            param pcie_desc = "DOE Busy";
        }
        field dis @ [1:1] is pcie_desc {
            param pcie_desc = "DOE Interrupt Status";
        }
        field de  @ [2:2] is pcie_desc {
            param pcie_desc = "DOE Error";
        }
        field dor @ [31:31] is pcie_desc {
            param pcie_desc = "Data Object Ready";
        }
    }

    register capability {
        field dis { param init_val default interrupt_support ? 1 : 0; }
        field dimn is (pcie_read, get) {
            param configuration = "pseudo";
            method get() -> (uint64) {
                return doe_get_dimn();
            }
            method pcie_read() -> (uint64) {
                return get();
            }
        }
    }

    register wdm {
        param configuration = "pseudo";

        method set(uint64 value) {
            return;
        }
        method pcie_write(uint64 value) {
            if (status.db.val == 1) {
                log spec_viol: "Attempt to write to DOE mailbox when busy";
                return;
            }
            try {
                w_mailbox.push(value);
            } catch {
                log error: "Mailbox buffer is full. Please ensure that the"
                    + " buffer length has been dimensioned correctly";
            }
        }
    }
    register rdm {
        param configuration = "pseudo";

        method set(uint64 value) {
            return;
        }
        method pcie_write(uint64 value) {
            if (status.dor.val == 0)
                return;

            try {
                local uint32 _ = r_mailbox.pop();
                if (r_mailbox.fifo_len == 0) {
                    status.dor.val = 0;
                }
            } catch {
                log info, 3: "Trying to read empty mailbox.";
            }
        }

        method get() -> (uint64) {
            if (status.dor.val == 0)
                return 0;

            local uint64 val;
            try {
                 val = r_mailbox.peek();
            }
            catch {
                log info, 3: "Trying to read empty mailbox.";
                val = 0;
            }
            return val;
        }
        method pcie_read() -> (uint64) {
            if (status.dor.val == 1) {
                return get();
            } else {
                log info, 3: "Reading mailbox when Data Object Ready bit is not"
                    + " set";
                return 0;
            }
        }
    }

    register control {
        field da {
            method pcie_write(uint64 value) {
                if (value == 1) {
                    w_mailbox.flush();
                    r_mailbox.flush();
                    doe_abort();
                    status.de.val = 0;
                    status.dor.val = 0;
                    status.db.val = 0;
                }
            }
        }
        field die {
            method pcie_write(uint64 value) {
                this.val = value;
                if (status.dis.val == 1) {
                    notify();
                }
            }
        }
        field dg {
            method pcie_write(uint64 value) {
                if (value == 0) {
                    return;
                }

                if (status.db.val == 1) {
                    log spec_viol: "Undefined behaviour: Setting Go bit when"
                        + " Busy bit is set";
                }
                status.db.val = 1;

                if (w_mailbox.fifo_len < 2) {
                    log spec_viol: "Undefined behaviour: write to Go bit"
                        + " with incomplete DOE request";
                    return;
                }

                local doe_header_t header;
                local uint32 data_object[w_mailbox.length];
                try {
                    w_mailbox.pop_buffer(data_object, w_mailbox.length, 2);
                    header = doe_header(data_object);
                } catch {
                    response_error();
                    return;
                }

                header.length = (header.length == 0) ? 2 : header.length;
                if (header.length == 1) {
                    log spec_viol: "Invalid DOE request length 1";
                    response_error();
                    return;
                }
                // -2 since we popped doe header
                if ((header.length -2) != w_mailbox.fifo_len) {
                    log info, 4: "Number of DW transferred (%d) does not match"
                        + " the indicated Length for data object (%d), silently"
                        + " discarding...", w_mailbox.fifo_len, header.length;
                    response_error();
                    return;
                }

                try {
                    w_mailbox.pop_buffer(&data_object[2], w_mailbox.length - 2,
                                         header.length - 2);
                } catch {
                    response_error();
                    return;
                }

                local doe_protocol protocol;
                try {
                    protocol = find_protocol(header.vendor_id,
                                             header.data_object_type);
                    log info, 3: "Incoming DOE protocol request for protocol"
                        + " with vendor id 0x%x, data object type 0x%x and"
                        + " length %d", protocol.vendor_id,
                        protocol.data_object_type, header.length;
                } catch {
                    log info, 3: "Could not find a protocol for vendor id"
                        + " 0x%x and data object type 0x%x. Silently discarding"
                        + " request...", header.vendor_id,
                        header.data_object_type;
                    clear_busy();
                    w_mailbox.flush();
                    return;
                }

                protocol.handle_request(data_object, header.length);
            }
        }
    }

    /**
    ### Methods
    * `method response_ready(uint18 res_len)`

      This method should be called when the incoming DOE request has been
      finnished processing. This means that if the request requires a response,
      that should have been written to the provided response buffer. In the case
      where no response is needed, or silently discarding the request is
      desried, this method should still be called but with \p res_len set to 0.

      @note After this method has been called, neither the request or the
      response buffer should be accessed.

      @note only one of `response_error()` and `response_ready()` should be
            called during the processing of a DOE request.

      `@param[in]  res_len The length of the response`<br/>
    */
    method response_ready(uint18 res_len) {
            assert(res_len <= mailbox_len);
            if (res_len > 0)
                data_ready();
            else
                clear_busy();
    }

    /**
    * `method response_error()`

      This method should be called when an internal error has been encountered
      during processing of the DOE request.

      @note After this method has been called, neither the request or the
      response buffer should be accessed.

      @note only one of `response_error()` and `response_ready()` should be
            called during the processing of a DOE request.
    */
    method response_error() {
        w_mailbox.flush();
        set_error();
    }


    method find_protocol(uint16 vendor_id, uint8 data_object_type)
        -> (doe_protocol) throws {
        foreach p in (supported_protocols) {
            if ((vendor_id == p.vendor_id) &&
                (data_object_type == p.data_object_type)) {
                return p;
            }
        }
        throw;
    }

    method notify() {
        if (capability.dis.val != 1 || control.die.val != 1) {
            return;
        }
        foreach cap in (each msix_capability in (parent)) {
            if (cap.is_enabled()) {
                cap.raise(doe_get_dimn());
                status.dis.val = 1;
                return;
            }
        }
        foreach cap in (each msi_capability in (parent)) {
            if (cap.is_enabled()) {
                cap.raise(doe_get_dimn());
                status.dis.val = 1;
                return;
            }
        }
    }

    method clear_busy() {
        status.db.val = 0;
        notify();
    }

    method set_error() {
        status.db.val = 0;
        status.de.val = 1;
        notify();
    }

    method data_ready() {
        status.dor.val = 1;
        status.db.val = 0;
        notify();
    }

/**
    * `shared method doe_abort()`
    This method can optionally be overridden to handle scenarios where doe
    requests are aborted.
*/
    shared method doe_abort() default { }

/**
    * `shared method doe_get_dimn() -> (uint11)`
    This method can optionally be overridden to control the value of the
    "DOE Interrupt Message Number" (dimn) bits. This provides the flexability
    to check the "Multiple Message Enable" bits in MSI for example, or other
    things might affect what the value of the dimn bits.
*/
    shared method doe_get_dimn() -> (uint11) default { return 0; }

#if (use_standard_access_templates) {
    register capability {
        field dis is hwinit;
        field dimn is read_only;
    }
    register status {
        field db  is read_only;
        field de  is read_only;
        field dor is read_only;
    }
}
#if (use_standard_write_templates) {
    register capability {
        field dimn is pcie_read;
    }
    register status {
        field dis is pcie_write_1_clears;
    }
    register wdm is (pcie_write);
    register rdm is (pcie_write, pcie_read);
    register control {
        field da is (pcie_write, read_zero);
        field die is (pcie_write);
        field dg is (pcie_write);
    }
}
}

template defining_doe_capability {
    param doe_offset;
    param doe_next_ptr;
    param doe_mailbox_len;
    param doe_interrupt_support;

    group doe is doe_capability {
        param interrupt_support = doe_interrupt_support;
        param base = doe_offset;
        param next_ptr = doe_next_ptr;
        param mailbox_len = doe_mailbox_len;
    }
}

/**
   ### DOE Templates
   * `template doe_protocol`

    The doe_protocol template should be used to define user-defined DOE
    protocols. These should be added to a doe_capability instance accordingly.
    The way this is done is by adding them to the protocols group in the
    doe_capability. Example:

    ```
    template doe_custom_protocol is doe_protocol {
        param vendor_id = 0x1234;
        param data_object_type = 0;

        shared method handle_request(const uint32 *req, uint18 req_len) {
            return 0;
        }
    }

    bank pcie_config {
        ...
        is defining_doe_capability;
        group doe {
            group protocols {
                group custom_protocol is doe_custom_protocol;
            }
        }
        ...
    }
    ```
 */
template doe_protocol {
    param vendor_id: uint16;
    param data_object_type: uint8;

    param mailbox default r_mailbox;

    /**
       #### Methods
       *  `shared method handle_request(const uint32 *req, uint18 req_len_dw);`

     The implementation of this abstract method should handle a DOE request for
     the implemented protocol. This method must at some point (or schedule an
     event that at some point) call the method `response_ready(res, res_len)` (
     or `response_error()` which is defined in the instantiating template
     doe_capability. This should be done when the response has been written to
     the `mailbox` fifo. The call should contain the length of the response.

     `@param[in]  res     The request buffer`<br/>
     `@param[in]  req_len The length of the request`<br/>
    */
    shared method handle_request(const uint32 *req, uint18 req_len_dw);
}

template doe_discovery is doe_protocol {
    param vendor_id = 0x0001;
    param data_object_type = 0x0;

    method handle_request(const uint32 *req, uint18 req_len_dw) {
        if (req_len_dw != 3) {
            log spec_viol: "Invalid DOE discovery request. Should only contain"
                + " one DW in addition to DOE header. Actual number of DWORDS:"
                + " %d", req_len_dw;
            response_error();
            return;
        }
        local uint8 index = req[2][7:0];
        if (index >= supported_protocols.len) {
            // Not specified in the PCIe spec when the index does not contain a
            // protocol. We will silently discard...
            log info, 2: "No supported DOE protocol on index %d. Discarding"
                + " request...", index;
            response_error();
            return;
        }

        local bitfields 32 {
            uint8 next_index @ [31:24];
            uint8 data_object_protocol @ [23:16];
            uint16 vendor_id @ [15:0];
        } res_dw1;
        local doe_protocol p = protocol_array()[index];
        res_dw1.vendor_id = p.vendor_id;
        res_dw1.data_object_protocol = p.data_object_type;
        if (index < (supported_protocols.len - 1))
            res_dw1.next_index = index + 1;

        local doe_header_t res_header;
        res_header.vendor_id = vendor_id;
        res_header.data_object_type = data_object_type;
        res_header.length = 3;

        local uint32 res[3];
        memcpy(res, &res_header, sizeof(res_header));
        res[2] = res_dw1;
        try {
            mailbox.push_buffer(res, sizeof(res) / sizeof(res[0]));
            response_ready(sizeof(res) / sizeof(res[0]));
        } catch {
            response_error();
        }
    }
}

template doe_mailbox {
    param length;

#if (true) { saved uint32 buffer[length]; }

    saved uint18 fifo_buf_start;
    saved uint18 fifo_len;

    method push(uint32 elem) throws {
        if (fifo_len >= length) throw;
        buffer[(fifo_buf_start + fifo_len++) % length] = elem;
    }

    method push_buffer(uint32 *buf, uint18 buf_len) throws {
        if (buf_len > (length - fifo_len)) {
            log error: "Mailbox FIFO is full, response will not be submitted";
            throw;
        }
        for (local int i = 0; i < buf_len; i++) {
            try {
                push(buf[i]);
            } catch {
                throw;
            }
        }
    }

    method peek() -> (uint32) throws {
        if (fifo_len == 0) throw;
        local uint32 elem = buffer[fifo_buf_start];
        return elem;
    }

    method pop() -> (uint32) throws {
        if (fifo_len == 0) throw;
        local uint32 elem = buffer[fifo_buf_start];
        fifo_buf_start = (fifo_buf_start + 1) % length;
        --fifo_len;
        return elem;
    }

    method pop_buffer(uint32 *buf, uint18 buf_len,
                      uint18 n_elems_to_pop) throws {
        if (n_elems_to_pop > buf_len)
            assert(false);
        if (n_elems_to_pop > fifo_len) {
            log error: "Too many elements to pop";
            throw;
        }
        for (local int i = 0; i < n_elems_to_pop; i++) {
            try {
                buf[i] = pop();
            } catch {
                throw;
            }
        }
    }

    method flush() {
        fifo_len = 0;
        fifo_buf_start = 0;
    }
}

typedef bitfields 64 {
    uint18 length @ [49:32];
    uint8 data_object_type @ [23:16];
    uint16 vendor_id @ [15:0];
} doe_header_t;

method doe_header(const uint32 *req) -> (doe_header_t) {
    local doe_header_t header;
    memcpy(&header, req, sizeof(header));
    return header;
}

/**
   ## Integrity and Data Encryption Extended Capability registers

    - name: `ide_capability`
    - implemented: registers only
*/
template ide_capability is extended_capability {
    param id = 0x30;
    param num_tcs default 1;
    param num_selective_streams default 1;
    param num_address_associations default 1;

    register capability size 4 @ (base + 0x04) is pcie_desc {
        param pcie_desc = "IDE Capabilities";
    }
    register control    size 4 @ (base + 0x08) is pcie_desc {
        param pcie_desc = "IDE Control";
    }

    group link_ide_register_block[i < num_tcs] {
        register lisc size 4 @ (base + 0xc + i * 8) is pcie_desc {
            param pcie_desc = "Link IDE Stream Control";
        }
        register liss size 4 @ (base + 0x10 + i * 8) is pcie_desc {
            param pcie_desc = "Link IDE Stream Status";
        }
    }

    group sisrb[i < num_selective_streams] {
        register sis_cap is (sisr, pcie_desc) {
            param pcie_desc = "Selective IDE Stream Capability";
            param block_offset = 0x0;
        }
        register sis_ctrl is (sisr, pcie_desc) {
            param pcie_desc = "Selective IDE Stream Control";
            param block_offset = 0x04;
        }
        register sis_status is (sisr, pcie_desc) {
            param pcie_desc = "Selective IDE Stream Status";
            param block_offset = 0x08;
        }
        register ira_1 is (sisr, pcie_desc) {
            param pcie_desc = "IDE RID Association Register 1";
            param block_offset = 0x0c;
        }
        register ira_2 is (sisr, pcie_desc) {
            param pcie_desc = "IDE RID Association Register 2";
            param block_offset = 0x10;
        }
        group siaarb[j < num_address_associations] {
            register iaar_1 is (siear, pcie_desc) {
                param pcie_desc = "IDE Address Association Register 1";
                param block_offset = 0x0;
            }
            register iaar_2 is (siear, pcie_desc) {
                param pcie_desc = "IDE Address Association Register 2";
                param block_offset = 0x4;
            }
            register iaar_3 is (siear, pcie_desc) {
                param pcie_desc = "IDE Address Association Register 3";
                param block_offset = 0x8;
            }
        }
    }

    register capability {
        field liss  @ [0:0] is pcie_desc {
            param pcie_desc = "Link IDE Stream Supported";
        }
        field siss  @ [1:1] is pcie_desc {
            param pcie_desc = "Selective IDE Streams Supported";
        }
        field fiss  @ [2:2] is pcie_desc {
            param pcie_desc = "Flow-Through IDE Stream Supported";
        }
        field phes  @ [3:3] is pcie_desc {
            param pcie_desc = "Partial Header Encryption Supported";
        }
        field asup  @ [4:4] is pcie_desc {
            param pcie_desc = "Aggregation Supported";
        }
        field psup  @ [5:5] is pcie_desc {
            param pcie_desc = "PCRC Supported ";
        }
        field ips   @ [6:6] is pcie_desc {
            param pcie_desc = "IDE_KM Protocol Supported ";
        }
        field sicrs @ [7:7] is pcie_desc {
            param pcie_desc = "Selective IDE for Configuration Requests Supported";
        }
        field salg  @ [12:8] is pcie_desc {
            param pcie_desc = "Supported Algorithms";
        }
        field ntsli @ [15:13] is pcie_desc {
            param pcie_desc = "Number of TCs Supported for Link IDE";
            param init_val default num_tcs;
        }
        field nsiss @ [23:16] is pcie_desc {
            param pcie_desc = "Number of Selective IDE Streams Supported";
            param init_val default num_selective_streams;
        }
    }

    register control {
        field fise @ [2:2] is pcie_desc {
            param pcie_desc = "Flow-Through IDE Stream Enabled";
        }
    }


    group link_ide_register_block[i < num_tcs] {
        register lisc {
            field lise @ [0:0] is pcie_desc {
                param pcie_desc = "Link IDE Stream Enable";
            }
            field tamn @ [3:2] is pcie_desc {
                param pcie_desc = "Tx Aggregation Mode NPR";
            }
            field tamp @ [5:4] is pcie_desc {
                param pcie_desc = "Tx Aggregation Mode PR";
            }
            field tamc @ [7:6] is pcie_desc {
                param pcie_desc = "Tx Aggregation Mode CPL";
            }
            field pe   @ [8:8] is pcie_desc {
                param pcie_desc = "PCRC Enable";
            }
            field sa   @ [18:14] is pcie_desc {
                param pcie_desc = "Selected Algorithm";
            }
            field tc   @ [21:19] is pcie_desc {
                param pcie_desc = "TC";
            }
            field sid  @ [31:24] is pcie_desc {
                param pcie_desc = "Stream ID";
            }
        }
        register liss {
            field liss  @ [3:0] is pcie_desc {
                param pcie_desc = "Link IDE Stream State";
            }
            field ricfm @ [31:31] is pcie_desc {
                param pcie_desc = "Received Integrity Check Fail Message";
            }
        }
    }

    group sisrb[i < num_selective_streams] {
        register sis_cap {
            field naarb @ [3:0] is pcie_desc {
                param pcie_desc = "Number of Address Association Register Blocks";
                param init_val default num_address_associations;
            }
        }
        register sis_ctrl {
            field sise  @ [0:0] is pcie_desc {
                param pcie_desc = "Selective IDE Stream Enable";
            }
            field tamn  @ [3:2] is pcie_desc {
                param pcie_desc = "Tx Aggregation Mode NPR";
            }
            field tamp  @ [5:4] is pcie_desc {
                param pcie_desc = "Tx Aggregation Mode PR";
            }
            field tamc  @ [7:6] is pcie_desc {
                param pcie_desc = "Tx Aggregation Mode CPL";
            }
            field pe    @ [8:8] is pcie_desc {
                param pcie_desc = "PCRC Enable";
            }
            field sicre @ [9:9] is pcie_desc {
                param pcie_desc = "Selective IDE for Configuration Requests Enable";
            }
            field phem  @ [13:10] is pcie_desc {
                param pcie_desc = "Partial Header Encryption Mode ";
            }
            field sa    @ [18:14] is pcie_desc {
                param pcie_desc = "Selected Algorithm";
            }
            field tc    @ [21:19] is pcie_desc {
                param pcie_desc = "TC";
            }
            field ds    @ [22:22] is pcie_desc {
                param pcie_desc = "Default Stream";
            }
            field sid  @ [31:24] is pcie_desc {
                param pcie_desc = "Stream ID";
            }
        }
        register sis_status {
            field liss  @ [3:0] is pcie_desc {
                param pcie_desc = "Link IDE Stream State";
            }
            field ricfm @ [31:31] is pcie_desc {
                param pcie_desc = "Received Integrity Check Fail Message";
            }
        }
        register ira_1 {
            field rl @ [23:8] is pcie_desc {
                param pcie_desc = "RID Limit";
            }
        }
        register ira_2 {
            field v @ [0:0] is pcie_desc {
                param pcie_desc = "Valid (V)";
            }
            field rl @ [23:8] is pcie_desc {
                param pcie_desc = "RID Limit";
            }
        }
        group siaarb[j < num_address_associations] {
            register iaar_1 {
                field v   @ [0:0] is pcie_desc {
                    param pcie_desc = "Valid (V)";
                }
                field mbl @ [19:8] is pcie_desc {
                    param pcie_desc = "Memory Base Lower";
                }
                field mll @ [31:20] is pcie_desc {
                    param pcie_desc = "Memory Limit Lower";
                }
            }
            register iaar_2 {
                field mlu @ [31:0] is pcie_desc {
                    param pcie_desc = "Memory Limit Upper";
                }
            }
            register iaar_3 {
                field mlu @ [31:0] is pcie_desc {
                    param pcie_desc = "Memory Limit Upper";
                }
            }
        }
    }

#if (use_standard_access_templates) {
    register capability is hwinit;
    group link_ide_register_block[i < num_tcs] {
        register lisc {
            field sa is pcie_read_only_conditional {
                param condition = lise.val == 1;
            }
        }
        register liss {
            field liss is read_only;
        }
    }
    group sisrb[i < num_selective_streams] {
        register sis_cap {
                field naarb is read_only;
            }
        register sis_ctrl {
            field phem is pcie_read_only_conditional {
                param condition = sise.val == 1;
            }
            field sa is pcie_read_only_conditional {
                param condition = sise.val == 1;
            }
        }
        register sis_status {
            field liss is read_only;
        }
    }
}
#if (use_standard_write_templates) {
    group link_ide_register_block[i < num_tcs] {
        register liss {
            field ricfm is pcie_write_1_clears;
        }
    }
    group sisrb[i < num_selective_streams] {
        register sis_status {
            field ricfm is pcie_write_1_clears;
        }
    }
}
}

template defining_ide_capability {
    param ide_offset;
    param ide_next_ptr;
    param ide_num_tcs;
    param ide_num_selective_streams;
    param ide_num_address_associations;

    group ide is ide_capability {
        param base = ide_offset;
        param next_ptr = ide_next_ptr;
        param num_tcs = ide_num_tcs;
        param num_selective_streams = ide_num_selective_streams;
        param num_address_associations = ide_num_address_associations;
    }
}

template sisr is register {
    param block_offset;
    param size = 4;
    param offset = (base + 12 + (8 * num_tcs) + block_offset
                    + i * (20 + (12 * num_address_associations)));
}

template siear is register {
    param block_offset;
    param size = 4;
    param offset = (base + 12 + (8 * num_tcs) + 20
                   + (i * (20 + (12 * num_address_associations)))
                   + block_offset + (j * 12));
}

template pcie_read_only_conditional is (field, write) {
    param condition default false;

    method owrite(uint64 value) default {
        this.set(value);
    }
    method write(uint64 value) {
        if (!condition) {
            owrite(value);
        } else {
            if (value != this.val) {
                log spec_viol: "Illegal write to %s", this.qname;
            }
        }
    }
}

/**
   ## Null Extended Capability registers

    - name: `null_capability_ext`
    - implemented: registers only
*/
template null_capability_ext is extended_capability {
    param id = 0x0;
}

template defining_null_ext_capability {
    param null_ext_offset;
    param null_ext_next_ptr;

    group null_ext is null_capability_ext {
        param base = null_ext_offset;
        param next_ptr = null_ext_next_ptr;
    }
}

/**
   ## Virtual Function Type 0 Bank

    - name: `vf_type_0_bank`
    - implemented: functional

   Can be used to implement Virtual Functions, used by SR-IOV capability.
   Inherits the `config_bank` template. Note that this template must use the
   `vf_base_address` template to implement its Base Address Registers.
*/
template vf_type_0_bank is (config_bank, pcie_function_level_reset) {
    param is_physical = false;
    param function = 0;  // not used;
    param vf_number: uint16;

    session type_0_bank physical_function;

    shared method set_physical_function(type_0_bank bank) {
        physical_function = bank;
    }

    implement pcie_function_info {
        method get_bar_map_obj(uint8 bar_offset) -> (conf_object_t *) default {
            local sriov_capability sriov;
            try {
                sriov = physical_function.get_sriov_capability();
            } catch { return NULL; }
            foreach bar in (sriov.each_vf_bar) {
                if (bar.offset == (sriov.get_base() + bar_offset)) {
                    try {
                        return bar.get_vf_bar_map(vf_number);
                    } catch { return NULL; }
                }
            }
            return NULL;
        }
    }

    register subsystem_vendor_id size 2 @ 0x2c is pcie_desc {
        param pcie_desc = "Subsystem Vendor ID";
    }
    register subsystem_id        size 2 @ 0x2e is pcie_desc {
        param pcie_desc = "Subsystem ID";
    }

    register vendor_id { param init_val default 0xFFFF; }
    register device_id { param init_val default 0xFFFF; }

#if (use_standard_access_templates) {
    register command {
        field io is (read_zero, ignore_write);
        field mem is (read_zero, ignore_write);
        field per is (read_zero, ignore_write);
        field se is (read_zero, ignore_write);
        field id is (read_zero, ignore_write);
    }

    register status {
        field ins is (read_zero, ignore_write);
    }

    register cache_line_size is (read_zero, ignore_write);
    register header_type is (read_zero, ignore_write);
    register bist is (read_zero, ignore_write);
    register interrupt_line is (read_zero, ignore_write);
    register interrupt_pin is (read_zero, ignore_write);
}

    shared method get_msix_capability() -> (msix_capability) throws;
    method get_msix_capability() -> (msix_capability) throws {
        foreach cap in (each msix_capability in (this)) {
            return cap;
        }
        throw;
    }
}

/**
   ## Virtual Function Base Address

    - name: `vf_base_address`
    - implemented: functional

   Can be used to implement Base Address Registers in the SR-IOV capability
   header. Inherits the template `memory_base_address`. Expects the parameter
   `map_obj` to be an array of mappable objects, one for each Virtual Function.
*/
template vf_base_address is memory_base_address {
    param bar_index = (offset - base - 0x24) / 4;
    param map_obj = undefined;
    saved uint64 map_length;

    shared method get_vf_bar_map(uint64 vf_number) -> (conf_object_t *) throws;

    method get_map_obj(uint64 i) -> (conf_object_t *) default {
        try {
            return get_vf_bar_map(i);
        } catch {
            return NULL;
        }
    }

    method get_size_bits() -> (uint8) default {
        local uint8 page_bits = log2_64(system_page_size.val << 12);
        local uint8 sz = size_bits;
        foreach reg in (each vf_rbar_control in (this.bank)) {
            if (reg.get_id() == bar_index)
                sz = reg.get_size_bits();
        }
        return page_bits > sz ? page_bits : sz;
    }

    method enabled() -> (bool) default {
        return control.vfe.val && control.vfmse.val;
    }

    method update_map() default {
        del_map();
        if (!enabled() || !upstream_target.connected())
            return;

        local map_info_t nfo = get_map_info();
        is_mapped = true;
        map_base = nfo.base;
        map_length = nfo.length;

        for (local int i = 1; i <= num_vfs.val; i++) {
            upstream_target.pcie_map.add_map(get_map_obj(i), nfo, map_type);
            try {
                local vf_type_0_bank vf = get_virtual_functions()[i];
                try {
                    local msix_capability msix = vf.get_msix_capability();
                    msix.update_map(bar_index, nfo);
                } catch { /* No MSI-X capability */ }
            } catch {
                log error: "Could not retrieve virtual function number %d", i;
                return;
            }
            nfo.base += nfo.length;
        }
    }

    method del_map() default {
        if (!is_mapped || !upstream_target.connected())
            return;

        for (local int i = 1; i <= virtual_functions.len; i++) {
            upstream_target.pcie_map.del_map(get_map_obj(i), map_base, map_type);
            try {
                local vf_type_0_bank vf = get_virtual_functions()[i];
                try {
                    local msix_capability msix = vf.get_msix_capability();
                    msix.del_map(bar_index);
                } catch { /* No MSI-X capability */ }
            } catch {
                log error: "Could not retrieve virtual function number %d", i;
                return;
            }
            map_base += map_length;
        }
        is_mapped = false;
    }
}

template vf_bar_32 is vf_base_address {
    param size = 4;
}

template vf_bar_64 is vf_base_address {
    param size = 8;
}
