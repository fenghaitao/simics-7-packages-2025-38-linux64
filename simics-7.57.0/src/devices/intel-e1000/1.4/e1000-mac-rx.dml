/*
  e1000-mac-rx.dml

  Â© 2010 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

dml 1.4;

extern uint32 UNALIGNED_LOAD_BE32(const void *p);

/* Multiple Rx queues parameters (RSS) */
param RETA_CNT = 128;

/* VLAN packet filter array size */
param VFTA_CNT = 128;

/* RSS Random Key array size */
param RSSRK_CNT = 40;

param RAH_ASEL_DESTINATION_ADDRESS = 0b00;
param RAH_ASEL_SOURCE_ADDRESS = 0b01;      // Currently not supported

param NUM_ETHTYPE_FILTERS = 8;

extern int sprintf(char *str, const char *format, ...);
extern int sscanf(const char *str, const char *format, ...);

/*
  The mac address of the device. When accessed as an attribute we handle it as
  a string in the standard format. Internally we store it in an uint64. Byte 0
  of the MAC address is stored in bits 0-7, byte 1 is stored in bit 8-15, and
  so on.
*/

attribute mac_address {
    param documentation = "MAC address ('XX:XX:XX:XX:XX:XX' string)";
    param configuration = "optional";
    session uint64 val;
    param type = "s";

    method get() -> (attr_value_t) {
        local char mac_str[18];
        sprintf(mac_str, "%02X:%02X:%02X:%02X:%02X:%02X",
                this.val[7:0], this.val[15:8], this.val[23:16],
                this.val[31:24], this.val[39:32], this.val[47:40]);
        return SIM_make_attr_string(mac_str);
    }

    method set(attr_value_t value) throws {
        local int mac_byte[6];
        if (sscanf(SIM_attr_string(value), "%x:%x:%x:%x:%x:%x",
                   &mac_byte[0], &mac_byte[1], &mac_byte[2],
                   &mac_byte[3], &mac_byte[4], &mac_byte[5]) == 6) {

            this.val[7:0]   = mac_byte[0];
            this.val[15:8]  = mac_byte[1];
            this.val[23:16] = mac_byte[2];
            this.val[31:24] = mac_byte[3];
            this.val[39:32] = mac_byte[4];
            this.val[47:40] = mac_byte[5];

            /* copy the MAC address to the RAL/RAH registers */
            memcpy(&csr.ra[0].low.val, &this.val, 4);
            csr.ra[0].high.rah.val = (this.val >> 32) & 0xffff;
            csr.ra[0].high.asel.val = RAH_ASEL_DESTINATION_ADDRESS;
            csr.ra[0].high.av.val = 1;
            if(HAS_EEPROM) {
                update_eeprom_macaddress(mac_byte);
                update_eeprom_alt_mac();
            }
        } else {
            throw;
        }
    }
}

bank csr {
    register rx_queue_nbr is (unmapped) "Current RX Queue";

    register rctl    @ 0x00100 "Receive Control";
    register fcrtl   @ 0x02160 "Flow Control Receive Threshold Low";
    register fcrth   @ 0x02168 "Flow Control Receive Threshold High";
    register rxcsum  @ 0x05000 "Receive Checksum Control";
    register rfctl   @ 0x05008 "Receive Filter Control";

    register mta[i < MTA_CNT] @ 0x05200 + i * 4 "Multicast Table Array";

    register fcrtl  is (flow_ctl_register);
    register fcrth  is (flow_ctl_register);

    #if(HAS_L2_ETHTYPE_FILTERS) {
        register etqf[i < NUM_ETHTYPE_FILTERS] @ 0x5cb0 + i * 4 "Etype Queue Filter";
        register etqf[i < NUM_ETHTYPE_FILTERS] {
            field queue_enable @ [31];
            field time_stamp @ [30];
            field immediate_interrupt @ [29];
            field filter_enable @ [26];
            field length_enable @ [25];
            field length @ [24:20];
            field rx_queue @ [19:16];  /* Up to 16 queues */
            field etype @ [15:0];
        }
    }

    #if(HAS_RSS_CPU_SELECTION) {
        register cpuvec  @ 0x02c10 "CPU Vector";
        register rssim   @ 0x05864 "RSS Interrupt Mask";
        register rssir   @ 0x05868 "RSS Interrupt Request";

        register cpuvec is (read, write) {
            method read() -> (uint64) {
                local uint64 value;
                value = this.val;
                rssim.val &= ~this.val;
                this.val = 0;
                icr.val[7] = 0;
                icr.val[16] = 0;
                icr.val[17] = 0;
                update_interrupt();
                return value;
            }
            method write(uint64 value) {
                rssim.val &= ~value;
            }
        }

        register rssim is write {
            method write(uint64 value) {
                this.val |= value;
            }
        }

        register rssir is (write_1_clears);
    } #else {
        register cpuvec  @ 0x02c10 is (unimpl) "CPU Vector";
        register rssim   @ 0x05864 is (unimpl) "RSS Interrupt Mask";
        register rssir   @ 0x05868 is (unimpl) "RSS Interrupt Request";
    }

    #if(HAS_RSS) {
        register reta[i < RETA_CNT]   size 1 @ 0x05c00 + i "Redirection Table";
        register rssrk[i < RSSRK_CNT] size 1 @ 0x05c80 + i "RSS Random Key";
    }

    #if(VLAN_PACKET_FILTER) {
        register vfta[i < VFTA_CNT] @ 0x05600 + i * 4 "VLAN Filter Table Array";
    }

    method receive_frame(dbuffer_t *buf, int crc_ok) default {
        if (rctl.en.val == 0) {
            log info, 4: "dropped incoming frame for receiver is disabled";
            return;
        }

        local const uint8 *frame = dbuffer_read_all(buf);
        local frame_info_t info;
        memset(&info, 0, sizeoftype(frame_info_t));
        info.length = dbuffer_len(buf);

        log info, 4: "received frame (%d bytes, crc_ok: %d)", info.length, crc_ok;
        count_total_rx_packet(info.length);
        dump_txrx_frame(buf, "Received frame");

        local bool gp;
        gp = rx_frame_precheck(frame, crc_ok, &info);
        if (!gp) {
            count_bad_rx_packet(info.length);
            return;
        }
        count_good_rx_packet(info.length, info.multi, info.bcst);

        local dbuffer_t    *clone   = NULL;
        clone = dbuffer_clone(buf);
        info.drop_it = false;
        info.l2_parse = true;
        info.l3_parse = true;
        try {
            l1_frame_parse(clone, frame, &info);
            if (info.drop_it) {
                log info, 2: "dropped received frame due to L1 filtering result";
                throw;
            }

            frame = dbuffer_read_all(clone);
            if (info.l2_parse) {
                l2_frame_parse(&frame[info.l2_index], &info);
                if (info.l3_parse) {
                    l3_frame_parse(frame, &info);

                    /* Encapsulated IPv6? */
                    if(info.ipv4_ipv6) {
                        l4_frame_parse(frame, &info);
                    }

                    #if (HAS_TIMESYNC) {
                        if (!info.fragmented) {
                            if (info.udp
                                && (info.l4_prot == UDP_EVENT_PORT_PTP
                                    || info.l4_prot == UDP_GENERAL_PORT_PTP)) {
                                check_timesync_post_l3_parse(clone,
                                                                   &info);
                                if (info.drop_it) {
                                    log info, 2: "drops received frame due"
                                        + " to TimeSync filter";
                                    throw;
                                }
                            }
                        }
                    }
                }
            }

            #if(HAS_RSS) {
                if (mrqc.mrqe.val == 0b01) {
                    calc_frame_rss_hash(&frame[info.l2_index], &info);
                } else {
                    info.hash = 0;
                    info.rss_type = 0;
                }
            }

            local bool empty;
            multiple_queue_select(&info);
            empty = rx_queue[rx_queue_nbr.val].check_descriptor(info.length);
            if (empty) {
                count_no_buffer();
                log info, 2: "discards incoming frame for lack of descriptor buffers";
                throw;
            }

            rx_queue[rx_queue_nbr.val].queue_store_packet(frame, &info);

            #if(HAS_RSS_CPU_SELECTION) {
                // Set the RSS interrupt request and CPU vector bit
                if (mrqc.mrqe.val != 0b00 && info.rss_type != 0) {
                    rssir.val |= (1 << info.cpu);
                    cpuvec.val = rssir.val & rssim.val;

                    if (cpuvec.val != 0) {
                        log unimpl:
                            "raise interrupt to specified CPU is unimplemented";
                    }
                }
            }

            rx_queue[rx_queue_nbr.val].rx_interrupt();

            #if(HAS_SMALL_PACKET_DETECTION) {
                if ((info.length + 4 * rctl.secrc.val) <= rsrpd.val) {
                    rx_delay.reinit();
                    raise_interrupt(INTR_SRPD | INTR_RXT0);
                }
            }

            #if(HAS_ACK_ACCELERATION) {
                if (info.ack)
                    ack_delay.raise(raid.val * 1.024e-6);
            }
        } catch {
            // do nothing
        }
        dbuffer_free(clone);
    }

    method rx_frame_precheck(const uint8* frame,
                             int crc_ok, frame_info_t *info) -> (bool) {
        local bool fcs_passed = true;
        local bool dst_passed;
        local bool vlan_passed = true;
        local bool len_passed = true;
        local int max_len = rctl.lpe.val == 0 ? 1522 : 16384;
        local eth_tagged_header_t *eth = cast(frame, void*);

        dst_passed = exact_address_filter(eth->da);
        info->pif = dst_passed;
        if (!dst_passed)
            dst_passed = packet_address_filter(eth->da, info);

        #if(VLAN_PACKET_FILTER) {
            vlan_passed = vlan_packet_filter(&eth->vtag, info);
        }

        if (crc_ok == 0) {
            info->cal_crc = calc_crc32(frame, info->length-4);
            info->rxd_crc =
                UNALIGNED_LOAD_BE32(cast(&frame[info->length-4], void*));
            if (info->cal_crc != info->rxd_crc) {
                info->rx_err = 1;
                fcs_passed = false;
                if (dst_passed && vlan_passed)
                    crcerrs.count(1);
                log info, 2: "received incorrect CRC 0x%x (expected 0x%x)",
                    info->rxd_crc, info->cal_crc;
            }
        }

        if (info->length < 64 || info->length > max_len) {
            len_passed = false;
            rlec.count(1);
            log info, 2: "received a frame with length error %d", info->length;
            if (dst_passed && vlan_passed) {
                if (fcs_passed) {
                    if (info->length < 64)
                        ruc.count(1);
                    else
                        roc.count(1);
                } else {
                    if (info->length < 64)
                        rfc.count(1);
                    else
                        rjc.count(1);
                }
            }
        }

        fcs_passed = (rctl.sbp.val != 0) ? true : fcs_passed;
        return fcs_passed && dst_passed && vlan_passed && len_passed;
    }

    method l1_frame_parse(dbuffer_t *buf,
                          const uint8 *frame, frame_info_t *info) default {
        local const ethernet_header_t *eth = cast(frame, void *);

        if (ctrl.vme.val == 1 && eth->type == ETH_TYPE_VLAN) {
            local const eth_tagged_header_t *th = cast(frame, void *);
            info->vp = true;
            info->vlan = th->vtag.vlan;
            info->type = th->type;
            info->l2_index = 18;
            log info, 4: "received VLAN tagged packet (vlan = %d, type = %d)",
                info->vlan, info->type;
        } else if (eth->type == ETH_TYPE_MACSEC) {
            info->type = ETH_TYPE_MACSEC;
            info->l2_parse = false;
#if (ICH10_ETHERNET_LAN) {
            log info, 4: "a MACsec tagged frame is received";
            check_linksec_post_l1_parse(buf, frame, info);
}
        } else if (eth->type == ETH_TYPE_PTP) {
            info->type = ETH_TYPE_PTP;
            info->l2_parse = false;
#if (HAS_TIMESYNC) {
            check_timesync_post_l1_parse(buf, frame, info);
}
        } else {
            info->type = eth->type;
            info->l2_index = 14;
        }

        if (info->type == ETH_TYPE_MACSEC)
            return;

        if (rctl.secrc.val == 1)
            info->length -= 4;//strip crc from frame

        if (info->vp) {
            dbuffer_remove(buf, 12, 4);//strip vlan tag
            info->length -= 4;//not stored to host memory
            info->l2_index -= 4;//l2_index points to first byte after eth hdr
        }

        // packet checksum
        local uint64 csv;
        csv = calc_checksum_value(&frame[rxcsum.pcss.val],
                                  info->length - rxcsum.pcss.val);
        info->packet_cs = checksum_to_16bit(csv, 0);
    }

    method l2_frame_parse(const uint8 *frame, frame_info_t *info) default {
        if (info->type == ETH_TYPE_IPv4) {
            local const ipv4_header_t *ipv4 = cast(frame, void*);
            log info, 4: "received IPv4 packet";

            info->ipv4 = true;
            info->ip_id = ipv4->id;
            info->l3_index = info->l2_index + ipv4->header.length * 4;
            info->l3_prot = ipv4->protocol;

            if(ipv4->fragment.flags[2] ||
               ipv4->fragment.frag_ofs > 0) {
                info->fragmented = true;
            }

            if (rxcsum.ipofld.val == 1) {
                local uint16 iphcs;
                iphcs = calc_ipv4_checksum(frame);
                info->ipe = (iphcs != ipv4->checksum);
                log info, 4: "calculated IPv4 checksum is 0x%04x", iphcs;
            }
        } else if (info->type == ETH_TYPE_IPv6) {
            local const ipv6_header_t *ipv6 = cast(frame, void *);
            local uint16 ipv6_hlen;
            log info, 4: "received IPv6 packet";

            info->ipv6 = true;
            (ipv6_hlen, info->l3_prot) = parse_ipv6_protocol(
                frame, info->length - info->l2_index);

            info->l3_index = info->l2_index + ipv6_hlen;
            info->ipv6_ext = ipv6_hlen > sizeoftype(ipv6_header_t);
        } else {
            log info, 4: "Ethernet type is %d",info->type;
        }
    }

    // frame starts from the beginning of the DA of the ethernet header
    method l3_frame_parse(const uint8 *frame, frame_info_t *info) default {
        local uint16 cs = 0;
        local tcp_header_t *th   = cast(frame + info->l3_index, void *);
        local udp_header_t *uh   = cast(frame + info->l3_index, void *);
        local ipv4_header_t *v4h = cast(frame + info->l2_index, void *);
        local ipv6_header_t *v6h = cast(frame + info->l2_index, void *);

        if (info->l3_prot == ETH_PROT_TCP) {
            info->tcp = true;
            info->l4_prot = th->dst_port;
            info->l4_index = info->l3_index + th->control.offset * 4;
            #if(HAS_ACK_ACCELERATION) {
                if ((rctl.dtyp.val == 0b01 || rfctl.exsten.val == 1)
                    && rfctl.ackdis.val == 0 && th->control.ack == 1) {
                    if (rfctl.ackd_dis.val == 1)
                        info->ack = true;
                    else if ((info->length - info->l3_index -
                              4 * (1 - rctl.secrc.val)) ==
                             (th->control.offset * 4))
                        info->ack = true; //no cp data
                }
            }
        }

        if (info->l3_prot == ETH_PROT_UDP) {
            info->udp = true;
            info->l4_prot  = uh->dst_port;
            info->l4_index = info->l3_index + 8;
        }

        if (info->l3_prot == ETH_PROT_IPV6_ENCAP) {
            info->ipv4_ipv6 = true;
            info->l4_prot  = uh->dst_port;

            local const ipv6_header_t *ipv6 =
                cast(&frame[info->l3_index], void *);
            local uint16 ipv6_hlen;
            log info, 4: "received encapsulated IPv6 packet";

            (ipv6_hlen, info->l5_prot) = parse_ipv6_protocol(
                cast(&frame[info->l3_index], void *),
                info->length - info->l3_index);

            info->l4_index = info->l3_index + ipv6_hlen;
        }

        if (rxcsum.tuofld.val == 0 ||
            (info->l3_prot != ETH_PROT_TCP && info->l3_prot != ETH_PROT_UDP))
            return;

        // Compare the checksum if required
        if (info->ipv4) {
            if (info->l3_prot == ETH_PROT_UDP && uh->checksum == 0) {
                // UDP checksum may be omitted for IPv4 (see RFC768, RFC2460)
                log info, 4: "no checksum in received IPv4-UDP packet";
                return;
            }

            local int l3_len = v4h->len - (v4h->header.length * 4);
            if ((l3_len + info->l3_index) <= info->length)
                cs = calc_tup_checksum_v4(frame + info->l3_index,
                                           info->l3_prot,
                                           v4h->src,
                                           v4h->dst,
                                           l3_len);
        } else if (info->ipv6) {
            if ((v6h->len + info->l3_index) <= info->length)
                cs = calc_tup_checksum_v6(frame + info->l3_index,
                                           info->l3_prot,
                                           cast(&v6h->src[0], uint8 *),
                                           cast(&v6h->dst[0], uint8 *),
                                           v6h->next,
                                           v6h->len);
        }

        log info, 4:
            "calculated checksum of received %s-%s packet is 0x%04x",
            info->ipv4 ? "IPv4" : "IPv6",
            (info->l3_prot == ETH_PROT_UDP) ? "UDP" : "TCP", cs;
        log info, 4: "expected checksum is 0x%04x",
            (info->l3_prot == ETH_PROT_UDP) ? uh->checksum : th->checksum;

        if (info->l3_prot == ETH_PROT_TCP)
            info->tupe = (cs != th->checksum);
        else if (info->l3_prot == ETH_PROT_UDP) {
                info->tupe = (cs != uh->checksum);
        }
    }

    // frame starts from the beginning of the DA of the ethernet header
    method l4_frame_parse(const uint8 *frame, frame_info_t *info) default {
        local tcp_header_t *th   = cast(frame + info->l4_index, void *);
        local udp_header_t *uh   = cast(frame + info->l4_index, void *);
        local ipv4_header_t *v4h = cast(frame + info->l3_index, void *);
        local ipv6_header_t *v6h = cast(frame + info->l3_index, void *);

        if (info->l4_prot == ETH_PROT_TCP) {
            info->l5_prot = th->dst_port;
            info->l5_index = info->l4_index + th->control.offset * 4;
        }

        if (info->l4_prot == ETH_PROT_UDP) {
            info->l5_prot  = uh->dst_port;
            info->l5_index = info->l4_index + 8;
        }
    }

    method l2_ethertype_filter(frame_info_t *info) -> (int) default {
        local int queue;
        local int i;
        for(i = 0;i < NUM_ETHTYPE_FILTERS;i++) {
            if(etqf[i].filter_enable.val != 0) {
                if(info->type == etqf[i].etype.val) {
                    if(etqf[i].queue_enable.val != 0) {
                        queue = etqf[i].rx_queue.val;
                        log info, 4:
                            "L2 Etype match in reg %d, queue %d selected",
                            i, queue;
                    }
                }
            }
        }
        return queue;
    }

    method multiple_queue_select(frame_info_t *info) default {
        local int queue = 0;

        #if(HAS_L2_ETHTYPE_FILTERS) {
            queue = l2_ethertype_filter(info);
        }

        rx_queue_nbr.val = queue;

        #if(HAS_RSS) {
            if (mrqc.mrqe.val > 0 && info->rss_type != 0) {
                local uint8 index = info->hash & 0x7F;
                rx_queue_nbr.val = reta[index].qidx.val;
                #if(HAS_RSS_CPU_SELECTION)
                    info->cpu = reta[index].cpu_idx.val;
            }
        }

        log info, 4: "rx_queue_nbr = %d", rx_queue_nbr.val;
    }

    method compare_mac_addr(uint48 pktaddr, uint64 regaddr) -> (bool) {
        local bool match;
        if (pktaddr[7:0] == regaddr[47:40] &&
            pktaddr[15:8] == regaddr[39:32] &&
            pktaddr[23:16] == regaddr[31:24] &&
            pktaddr[31:24] == regaddr[23:16] &&
            pktaddr[39:32] == regaddr[15:8] &&
            pktaddr[47:40] == regaddr[7:0]) {
            match = true;
        } else {
            match = false;
        }

        log info, 4: "comparing pktaddr (%02X:%02X:%02X:%02X:%02X:%02X) regaddr (%02X:%02X:%02X:%02X:%02X:%02X), %s",
            pktaddr[47:40], pktaddr[39:32], pktaddr[31:24],
            pktaddr[23:16], pktaddr[15:8], pktaddr[7:0],
            regaddr[7:0], regaddr[15:8], regaddr[23:16],
            regaddr[31:24], regaddr[39:32], regaddr[47:40],
            match ? "match" : "mismatch";
        return match;
    }

    method packet_address_filter(uint48 da, frame_info_t *info) -> (bool) default {
        local bool passed;
        local bool m;
        passed = true;

        // broadcast filtering
        if (da == ETH_BRCT_MAC) {
            passed = rctl.bam.val == 1;
            info->bcst = true;
            log info, 4:
                "%s a broadcast frame", passed ? "accepted" : "rejected";
            return passed;
        }

        // multicast filtering
        if ((da & ETH_MULTI_MSK) != 0) {
            info->multi = true;
            if (rctl.mpe.val == 1) {
                log info, 4:
                    "received a multicast frame (mpe = 1, da = 0x%x)", da;
                return passed;
            }

            // Check the Multicast Table Array
            #if (MTA_CNT == 128) {
                local uint8 byte6 = da[7:0];
                local uint8 byte5 = da[15:8];
                local uint7 dw_address;
                local uint5 bit_address;
                switch(rctl.mo.val) {
                case 0b00:
                    dw_address = byte6[7:1];
                    bit_address = (byte6[0] << 4) | byte5[3:0];
                    break;
                case 0b01:
                    dw_address = byte6[6:0];
                    bit_address = byte5[4:0];
                    break;
                case 0b10:
                    dw_address = (byte6[5:0] << 1) | byte5[5];
                    bit_address = byte5[4:0];
                    break;
                case 0b11:
                    dw_address = (byte6[3:0] << 3) | byte5[7:5];
                    bit_address = byte5[4:0];
                    break;
                default:
                    assert false;
                }
                passed = (mta[dw_address].val & (1 << bit_address)) != 0;
            } #else #if (MTA_CNT == 32) {
                local uint8 byte6 = da[7:0];
                local uint8 byte5 = da[15:8];
                local uint5 dw_address;
                local uint5 bit_address;
                switch(rctl.mo) {
                case 0b00:
                    dw_address = byte6[7:3];
                    bit_address = (byte6[2:0] << 2) | byte5[1:0];
                    break;
                case 0b01:
                    dw_address = byte6[6:2];
                    bit_address = (byte6[1:0] << 3) | byte5[2:0];
                    break;
                case 0b10:
                    dw_address = byte6[5:1];
                    bit_address = (byte6[0] << 4) | byte5[3:0];
                    break;
                case 0b11:
                    dw_address = (byte6[3:0] << 1) | byte5[5];
                    bit_address = byte5[4:0];
                    break;
                default:
                    assert false;
                }
                passed = (mta[dw_address] & (1 << bit_address)) != 0;
            } #else {
                error "Add your code here to handle new MTA_CNT value";
            }
            log info, 4: "%s a multicast frame (mpe = 0, da = 0x%x)",
                passed ? "accepted" : "rejected", da;
            return passed;
        }

        // unicast filtering
        if (rctl.upe.val == 1) {
            log info, 4: "accepted an Ethernet frame for unicast promiscuous mode is enabled";
            return passed;
        }

        log info, 3: "received an unknown Ethernet frame from da 0x%x", da;
        return false;
    }

    method parse_ipv6_protocol(const uint8 *frame, uint16 length)
        -> (uint16, uint8) /* hlen, prot */ default {
        local uint16 hlen;
        local uint8 prot;
        local const ipv6_header_t *ipv6 = cast(frame, void*);

        hlen = sizeoftype(ipv6_header_t);
        prot = ipv6->next;

        while (prot == IPv6_NH_HOPBYHOP || prot == IPv6_NH_DEST_OPT ||
               prot == IPv6_NH_ROUTING) {
            local const ipv6_ext_header_t *eh = cast(&frame[hlen], void*);
            if ((hlen + eh->ext_hlen) >= length) {
                log spec_viol, 1:
                    "the IPv6 frame doesn't contain a valid protocol field";
                 break;
            }

            prot = eh->next;
            if (eh->ext_hlen == 0) {
                log spec_viol,1: "the IPv6 frame has zero hlen";
                break;
            }
            hlen += eh->ext_hlen;
        }
        return (hlen, prot);
    }

    #if(HAS_RSS) {
        method load_random_key(uint8 *key) default {
            local int i;

            for (i = 0; i < 40; i++)
                key[i] = rssrk[i].val;
        }

        method calc_frame_rss_hash(const uint8 *ip,
                                   frame_info_t *info) default {
            if (mrqc.rssfe.val != 0) {
                if (info->ipv4) {
                    if (info->l3_prot == ETH_PROT_TCP && mrqc.rssfe.val[0] != 0)
                        info->rss_type = 1;
                    else if (mrqc.rssfe.val[1] != 0)
                        info->rss_type = 2;
                } else if (info->ipv6) {
                    if (info->l3_prot == ETH_PROT_TCP && mrqc.rssfe.val[2] != 0)
                        info->rss_type = 3;
                    else if (mrqc.rssfe.val[3] != 0 && info->ipv6_ext)
                        info->rss_type = 4;
                    else if (mrqc.rssfe.val[4] != 0)
                        info->rss_type = 5;
                }
            }

            if (info->rss_type != 0) {
                info->hash = compute_ip_hash(ip, info->ipv6,
                                      info->rss_type == 1 || info->rss_type == 3);
                return;
            }

            info->hash = 0;
            info->rss_type = 0;
            rx_queue_nbr.val = 0;
        }
    }

    method exact_address_filter(uint48 da) -> (bool) default {
        local bool passed;
        local int i;
        local bool m;
        passed = true;
        for (i = 0; i < RA_CNT; i++) {
            m = compare_mac_addr(da, ra[i].mac.val);
            if (ra[i].high.av.val == 1 && m)
                return passed;
        }
        return false;
    }

    #if(VLAN_PACKET_FILTER) {
        method vlan_packet_filter(ieee_802_1q_tag_t *vtag, frame_info_t *info)
            -> (bool) default {
            local bool passed;
            passed = true;

            if (vtag->TagVal != vet.val)
                return passed; // not a 802.1q TAG

            if (rctl.cfien.val == 1) {
                // Packet.CFI must match rctl.CFI
                passed = rctl.cfi.val == vtag->vlan.cfi;
                log info, 4: "%s Canonical Form Indicator",
                    passed ? "accepted" : "rejected";
                if (!passed)
                    return passed;
            }

            if (rctl.vfe.val == 0)
                return passed;

            /* Check the VLAN Filter Table.
             * Same algorithm as used for multicast filtering.
             */
            local uint12 index = vtag->vlan.vid;
            passed = (vfta[index/32].val & (1 << (index % 32))) != 0;
            log info, 4: "%s VLAN Filter Table", passed ? "accepted" : "rejected";
            return passed;
            return passed;
        }
    }
}

//length of key should be 40B
method compute_hash (
    const uint8 *data, int length, uint8 *key) -> (uint32) default {
    local uint32 hash;

    local int i;
    hash = 0;

    for (i = 0; i < length; i++) {
        local uint8 byte = data[i];
        local int j;

        for (j = 7; j >= 0; j--) {
            if ((byte & (1 << j)) != 0)
                hash ^= UNALIGNED_LOAD_BE32(cast(key, void *));

            local int k;
            local uint1 bit0 = 0;
            local uint1 bit1 = 0;
            for (k = 39; k >= 0; k--) {
                bit1 = key[k][7:7];
                key[k] = (key[k] << 1) | bit0;
                bit0 = bit1;
            }
        }
    }
    return hash;
}

method compute_ip_hash(const uint8 *ip, bool v6, bool tcp) -> (uint32) {
    local uint32 hash;
    local int start = v6 ? 8 : 12;
    local int length = (v6 ? 32 : 8) + (tcp ? 4 : 0);
    local uint8 key[40];

    csr.load_random_key(key);
    hash = compute_hash(&ip[start], length, key);
    return hash;
}

template rx_mac_register {
    register low is (set, write) {
        method set(uint64 val) {
            this.val = val;
            mac.val[31:0] = this.val;
        }
        method write(uint64 val) {
            set(val);
        }
    }
    register high {
        field rah @ [15:0] is (set, write) "Receive Address High" {
            method set(uint64 val) {
                this.val = val;
                mac.val[47:32] = this.val & 0xFFFF;
            }
            method write(uint64 val) {
                set(val);
            }
        }
        field asel @ [17:16] is write "Address Select" {
            method write(uint64 val) {
                // no other asel values are currently supported
                this.val = RAH_ASEL_DESTINATION_ADDRESS;
                if (val != RAH_ASEL_DESTINATION_ADDRESS)
                    log unimpl, 1, Register_Write:
                        "%s only supports Destination Address (0)", qname;
            }
        }
        // reserved[30:18]
        field av @ [31] "Address Valid";
    }
    register mac size 8 "Receive MAC address" {
        is unmapped;
    }
}

template intr_delay_evt is simple_time_event {
    param INTR;
    method event() {
        raise_interrupt(INTR);
    }

    method raise(double time) default {
        local bool is_posted;
        is_posted = posted();
        if (!is_posted)
            post(time);
    }

    method reinit() default {
        local bool is_posted;
        is_posted = posted();
        if (is_posted)
            remove();
    }
}

param DESC_SIZE = 2*8;
param SPLIT_DESC_SIZE = 4*8;

template rx_desc_queue {
    param BA    default undefined;
    param rdmts default undefined;
    param dtyp  default undefined;

    register rdbal @ BA + 0x00 "Receive Descriptor Base Low";
    register rdbah @ BA + 0x04 "Receive Descriptor Base High";
    register rdlen @ BA + 0x08 "Receive Descriptor Length";
    register rdh   @ BA + 0x10 "Receive Descriptor Header";
    register rdt   @ BA + 0x18 "Receive Descriptor Tail";
    register rxdctl@ BA + 0x28 "Receive Descriptor Control";

    register rdbal is (write_mask) { param mask = 0xFFFFFFF0; }
    register rdbah is (write_mask) { param mask = 0xFFFFFFFF; }
    register rdlen is (write_mask) { param mask = 0x000FFF80; }
    register rdh   is (write_mask) { param mask = 0x0000FFFF; }
    register rdt   is (write_mask) { param mask = 0x0000FFFF; }

    method load_descriptor(uint8 *desc,
                           int desc_size) -> (uint64) throws default {
        local uint64 addr;
        addr = ((rdbah.val << 32) | rdbal.val) + rdh.val * 16;
        log info, 4: "load %d-byte descriptor from addr: 0x%x",
            desc_size, addr;
        memory_read(&desc[0], addr, desc_size);
        return addr;
    }

    method increase_header(int desc_size) default {
        local uint16 n = rdlen.val / DESC_SIZE;
        rdh.val = (rdh.val + desc_size / DESC_SIZE) % n;

        local int avail = (rdt.val >= rdh.val) ? (rdt.val - rdh.val) : (n + rdt.val - rdh.val);

        if (avail == (n >> (rdmts.val + 1)))
            raise_interrupt(INTR_RXDMT0);

        if (rdh.val == rdt.val)
            log info, 2: "the receive descriptor ring is empty";
    }

    method save_packet_legacy(const uint8* frame, frame_info_t *info) throws {
        local uint16 buf_size;
        local uint16 index = 0;
        local uint8 desc[16];
        local uint64 daddr;

        buf_size = buffer_size();
        while (index < info->length) {
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local legacy_rx_desc_t *lrd = cast(desc, void*);
            daddr = load_descriptor(desc, DESC_SIZE);
            log info, 4: "write packet to memory: addr: 0x%x, step: %d", lrd->buf_addr, step;
            memory_write(lrd->buf_addr, &frame[index], step);
            index += step;

            if (info->vp) {
                lrd->desc.pri  = info->vlan[15:13];
                lrd->desc.cfi  = info->vlan[12:12];
                lrd->desc.vlan = info->vlan[11:0];
            }
            lrd->desc.rxe    = info->rx_err;
            lrd->desc.ipe    = info->ipe;
            lrd->desc.tcpe   = (info->tupe) ? 1 : 0;
            lrd->desc.ce     = (info->cal_crc == info->rxd_crc) ? 0 : 1;
            lrd->desc.pif    = info->pif;
            lrd->desc.ipcs   = rxcsum.ipofld.val;
            lrd->desc.vp     = info->vp ? 1 : 0;
            lrd->desc.eop    = (index == info->length) ? 1 : 0;
            lrd->desc.dd     = 1;
            lrd->desc.fcs    = info->packet_cs;
            lrd->desc.length = step;

            if (lrd->desc.ipcs) {
                lrd->desc.tcpcs = 1;
                lrd->desc.udpcs = info->udp ? 1 : 0;
            } else if (info->ipv6 && (info->tcp || info->udp)) {
                /* Documentation states that IPv6 packets do not have the IPCS
                 * bit set, but might have the TCPCS bit set if a TCP or UDP
                 * packet was recognized.
                 */
                lrd->desc.tcpcs = 1;
            }

            memory_write(daddr, desc, DESC_SIZE);

            log info, 3: "%s(%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d, %s=%04x) at 0x%x",
                "saving legacy descriptor", "rxe", lrd->desc.rxe,
                "ipe", lrd->desc.ipe, "tcpe", lrd->desc.tcpe,
                "ce", lrd->desc.ce, "eop", lrd->desc.eop,
                "length", lrd->desc.length,
                "tcpcs", lrd->desc.tcpcs,
                "udpcs", lrd->desc.udpcs,
                "fcs", lrd->desc.fcs,
                daddr;

            increase_header(DESC_SIZE);
        }
    }
}

template rx_desc_queue_alias {
    param BA default undefined;
    param reggroup default undefined;

    register rdbal  @ BA + 0x00 is (register_alias) {
        param target = reggroup[i].rdbal;
    }
    register rdbah  @ BA + 0x04 is (register_alias) {
        param target = reggroup[i].rdbah;
    }
    register rdlen  @ BA + 0x08 is (register_alias) {
        param target = reggroup[i].rdlen;
    }
    register rdh    @ BA + 0x10 is (register_alias) {
        param target = reggroup[i].rdh;
    }
    register rdt    @ BA + 0x18 is (register_alias) {
        param target = reggroup[i].rdt;
    }
    register rxdctl @ BA + 0x28 is (register_alias) {
        param target = reggroup[i].rxdctl;
    }
}

template ext_rx_desc_queue {
    param bsize  default undefined;
    param bsex   default undefined;
    param flxbuf default undefined;
    param psr_sz default undefined;

    register rdtr  @ BA + 0x20 "Receive Interrupt Packet Delay Timer";

    register rdtr {
        field delay @ [15:0] "Receive Delay Timer";
        field fpd @ [31] is (write) "Flush Partial Descriptor" {
            method write(uint64 value) {
                if (value == 1) {
                    local bool is_posted;
                    is_posted = rx_delay.posted();
                    if (is_posted)
                        rx_delay.remove();
                    raise_interrupt(INTR_RXT0);
                }
            }
        }
    }

    register rxdctl {
        field pthresh @ [5:0] is (unimpl) "Prefetch Threshold";
        field hthresh @ [13:8] is (unimpl) "Host Threshold";
        field wthresh @ [21:16] is (unimpl) "Write-back Threshold";
        field gran @ [24] is (unimpl) "Granularity";
    }

    method buffer_size() -> (uint16) default {
        return flxbuf.val != 0
               ? 1024 * flxbuf.val : (2048 >> bsize.val) * (bsex.val == 1 ? 16 : 1);
    }

    method check_descriptor(uint16 length) -> (bool) default {
        local bool empty;
        empty = false;

        if (rdh.val == rdt.val) {
            log info, 4: "check RX descriptor: empty based on rdh (%d) and rdt (%d)", rdh.val, rdt.val;
            return true;
        }

        /* We can only span over non-split descriptors */
        if (dtyp.val == 0b00 || rfctl.exsten.val == 0) {
            local uint16 buf_size;
            local uint16 desc_cnt = (rdt.val > rdh.val ? (rdt.val - rdh.val)
                                     : (rdlen.val / 16 + rdt.val - rdh.val));
            buf_size = buffer_size();
            empty = (desc_cnt * buf_size) < length;
            log info, 4: "check Rx descriptor: %s based on rdh (%d) and rdt(%d)", empty ? "empty" : "non-empty", rdh.val, rdt.val;
        }
        return empty;
    }

    method queue_store_packet(const uint8* frame, frame_info_t *info) throws default {
        if (dtyp.val == 0b00 && rfctl.exsten.val == 0) {
            save_packet_legacy(frame, info);
        } else if (dtyp.val == 0b00 && rfctl.exsten.val == 1) {
            save_packet_extended(frame, info);
        } else if (dtyp.val == 1 && rfctl.exsten.val == 1) {
            save_packet_split(frame, info);
        } else {
            log spec_viol, 1:
                "invalid configuration: dtyp=%d, exsten=%d, %s",
                dtyp.val, rfctl.exsten.val, "discards incoming frame";
            throw;
        }
    }

    method rx_interrupt() default {
        // re-initialise and start the RX delay timer
        rx_delay.reinit();

        // MTDq (Direct mapped virtualization) has one RDTR per queue
        #if(HAS_MTDq1)
            rx_delay.raise(rdtr.delay * 1.024e-6);
        #else
            rx_delay.raise(csr.rx_queue[0].rdtr.delay.val * 1.024e-6);
    }

    method save_packet_extended(const uint8 *frame,
                                frame_info_t *info) throws default {
        local uint16 buf_size;
        local uint8  desc[16];
        local uint64 daddr;
        local uint16 index = 0;

        buf_size = buffer_size();
        while (index < info->length) {
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local ext_rd_rx_desc_t *rrd = cast(desc, void*);
            local ext_wb_rx_desc_t *wrd = cast(desc, void*);

            daddr = load_descriptor(desc, DESC_SIZE);
            memory_write(rrd->buf_addr, &frame[index], step);
            index += step;
            memset(wrd, 0, 16);

            #if(HAS_RSS) {
                wrd->desc0.rss_info = rxcsum.pcsd.val != 0 ?
                    info->hash : (info->packet_cs << 16) | info->ip_id;
                wrd->desc0.queue    = i;
                wrd->desc0.rss_type = info->rss_type;
            }

            if (info->vp) {
                wrd->desc1.pri  = info->vlan[15:13];
                wrd->desc1.cfi  = info->vlan[12:12];
                wrd->desc1.vlan = info->vlan[11:0];
                wrd->desc1.vp   = 1;
            }
            wrd->desc1.length   = info->length;
            wrd->desc1.rxe      = info->rx_err;
            wrd->desc1.tcpe     = info->tupe ? 1 : 0;
            wrd->desc1.ipe      = info->ipe ? 1 : 0;
            wrd->desc1.ce       = (info->cal_crc == info->rxd_crc) ? 0: 1;
            //      if (info->ipv4)
            //          wrd->desc1.pkttype  = (info->tcp || info->udp) ?
            //              $PKTTYPE_MAC_IPV4_TCP_UDP : $PKTTYPE_MAC_IPV4_PAYLOAD;
            //      else if (info->ipv6)
            //          wrd->desc1.pkttype  = (info->tcp || info->udp) ?
            //              $PKTTYPE_MAC_IPV6_TCP_UDP : $PKTTYPE_MAC_IPV6_PAYLOAD;
            //      else
            //          wrd->desc1.pkttype = 0;
            wrd->desc1.ack      = info->ack ? 1 : 0;
            wrd->desc1.udpv     = 0;
            wrd->desc1.ipidv    = info->ipv4 ? 1 - rxcsum.pcsd.val : 0;
            wrd->desc1.tst      = info->tst;
            wrd->desc1.pif      = info->pif;
            wrd->desc1.ipcs     = info->ipv4 ? rxcsum.ipofld.val :0;
            wrd->desc1.eop      = index == info->length ? 1 : 0;
            wrd->desc1.dd       = info->length == index ? 1 : 0;

            if (wrd->desc1.ipcs) {
                wrd->desc1.tcpcs = 1;
                wrd->desc1.udpcs = info->udp ? 1 : 0;
            } else if (info->ipv6 && (info->tcp || info->udp)) {
                /* Documentation states that IPv6 packets do not have the IPCS
                 * bit set, but might have the TCPCS bit set if a TCP or UDP
                 * packet was recognized.
                 */
                wrd->desc1.tcpcs = 1;
            }

            log info, 3:
                "%s(%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d) at 0x%x",
                "saving extended descriptor", "vp", wrd->desc1.vp,
                "rxe", wrd->desc1.rxe, "tcpe", wrd->desc1.tcpe,
                "ipe", wrd->desc1.ipe, "ce", wrd->desc1.ce,
                "ack", wrd->desc1.ack, "length", wrd->desc1.length,
                "eop", wrd->desc1.eop, daddr;

            memory_write(daddr, &desc[0], DESC_SIZE);
            increase_header(DESC_SIZE);
        }
    }

    method save_packet_split(const uint8* frame, frame_info_t *info) throws {
        local uint8  desc[32];
        local uint64 daddr;
        daddr = load_descriptor(desc, SPLIT_DESC_SIZE);

        local split_rd_rx_desc_t *srd = cast(desc, void*);
        local int i;
        local uint64 paddr[4];
        local uint16 length[4];
        for (i = 0; i < 4; i++)
            paddr[i] = srd->buf_addr[i];

        local uint16 index = 0;
        local split_wb_rx_desc_t *swd = cast(desc, void*);
        memset(desc, 0, 32);
        memset(length, 0, 4 * sizeoftype(uint16));

        for (i = 0; i < 4 && info->length > index; i++) {
            local uint16 remainder = info->length - index;
            length[i] = split_buffer_size(i);
            if (length[i] > remainder)
                length[i] = remainder;

            memory_write(paddr[i], &frame[index], length[i]);
            index += length[i];
        }

        if (index < info->length)
            log spec_viol, 1:
                "%d bytes of ingoing frame dropped for lack of memory space",
                info->length - index;

        //write-back descriptor
        #if(HAS_RSS) {
            swd->desc0.rss_info = rxcsum.pcsd.val != 0 ?
                info->hash : (info->packet_cs << 16) | info->ip_id;
            swd->desc0.queue    = this.i;
            swd->desc0.rss_type = info->rss_type;
        }

        if (info->vp) {
            swd->desc1.pri  = info->vlan[15:13];
            swd->desc1.cfi  = info->vlan[12:12];
            swd->desc1.vlan = info->vlan[11:0];
            swd->desc1.vp   = 1;
        }
        swd->desc1.length   = length[0];
        swd->desc1.dd       = 1;

        swd->desc2.length1  = length[1];
        swd->desc2.length2  = length[2];
        swd->desc2.length3  = length[3];
        swd->desc2.hdrsp    = 0;
        swd->desc2.hlen     = 0;

        #if(HAS_RSS) {
            log info, 3:
                "%s(%s=0x%x,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d,%s=%d) at 0x%x",
                "saving split descriptor",
                "rss_info", swd->desc0.rss_info,
                "rss_type", swd->desc0.rss_type,
                "queue", swd->desc0.queue,
                "vp", swd->desc1.vp,
                "length[0]", swd->desc1.length,
                "length[1]", swd->desc2.length1,
                "length[2]", swd->desc2.length2,
                "length[3]", swd->desc2.length3, daddr;
        } #else {
            log info, 3:
                "%s(%s=%d,%s=%d,%s=%d,%s=%d,%s=%d) at 0x%x",
                "saving split descriptor",
                "vp", swd->desc1.vp,
                "length[0]", swd->desc1.length,
                "length[1]", swd->desc2.length1,
                "length[2]", swd->desc2.length2,
                "length[3]", swd->desc2.length3, daddr;
        }
        memory_write(daddr, desc, SPLIT_DESC_SIZE);
        increase_header(SPLIT_DESC_SIZE);
    }

    method split_buffer_size(uint2 pn) -> (uint16) default {
        return ((psr_sz.val >> (pn * 8)) & 0x7F) * (pn == 0 ? 128 : 1024);
    }
}

template adv_rx_desc_queue {
    param bsize  default undefined;
    param bsize_pkt  default undefined;
    param bsize_header  default undefined;

    register srrctl @ BA + 0x0c "Split and Replication Rx Control";

    register rxdctl {
        field pthresh @ [4:0] "Prefetch Threshold";
        // reserved[7:5]
        field hthresh @ [12:8] "Host Threshold";
        // reserved[15:13]
        field wthresh @ [20:16] "write-back Threshold";
        // reserved[24:21]
        field en @ [25] "Enabled";
        field swflush @ [26]  is (write) "Receive Software Flush" {
            method write(uint64 value) {
                if (value == 1) {
                    rx_delay.raise(eitr[ivar[0].alloc.val].interval.val * 1e-6);
                }
            }
        }
        // reserved[31:27]
    }

    register srrctl {
        field bszpkt @ [6:0] "RX Buffer size";
        field bszhdr @ [11:8] "RX Buffer size for header buffer";
        field rdmts @ [24:20] "RX desc min threshold size";
        field desctype @ [27:25] "rx descriptor type";
        field drop_en @ [31] "Drop_En";
    }

    method check_descriptor(uint16 length) -> (bool) {
        local bool empty;
        empty = false;
        if (rdh.val == rdt.val) {
            log info, 4: "check RX descriptor: empty based on rdh (%d) and rdt (%d)", rdh.val, rdt.val;
            return true;
        }

        if (dtyp.val <= 5) {
            local uint16 buf_size;
            local uint16 header_size;
            local uint16 desc_cnt = (rdt.val > rdh.val ? (rdt.val - rdh.val)
                                     : (rdlen.val / 16 + rdt.val - rdh.val));
            buf_size = buffer_size();
            header_size = this.header_size();
            /* Header size is only included in the first descriptor */
            empty = (header_size + desc_cnt * buf_size) < length;
            log info, 4: "check RX descriptor: %s based on rdh (%d) and rdt (%d)", empty ? "empty" : "non-empty", rdh.val, rdt.val;
        }
        return empty;
    }

    method queue_store_packet(const uint8* frame, frame_info_t *info) throws {
        if (dtyp.val == 0b000) {
            save_packet_legacy(frame, info);
        } else if (dtyp.val == 1) {
            save_packet_one_buffer(frame, info);
        } else if (dtyp.val == 5) {
            save_packet_split_always_use_header(frame, info);
        } else {
            log spec_viol, 1: "invalid configuration: dtyp=%d, %s",
                dtyp.val, "discards incoming frame";
            throw;
        }
    }

    method rx_interrupt() default {
        if (eitr[ivar[0].alloc.val].cntwdis.val == 1)
            rx_delay.raise(eitr[ivar[0].alloc.val].interval.val * 1e-6);
        else
            rx_delay.raise(eitr[ivar[0].alloc.val].counter.val * 1e-6);
    }

    method get_split_type(const uint8 *frame,
                          frame_info_t *info) -> (uint16, uint16) /* type, split */ {
        local uint16 type;
        local uint16 split;
        split = 0;
        type = 0;

        /* TODO: We're not handling NFS in L4/L5*/

        if(info->ipv4) {
            if(info->fragmented) {
                if(ptype.val[1]) {
                    /* Type 1: L3 split if fragmented IPv4 */
                    type = 1;
                    split = info->l3_index;
                }
            } else {
                if(info->tcp && ptype.val[2]) {
                    /* Type 2: L4 split if IPv4, TCP */
                    type = 2;
                    split = info->l4_index;
                }

                if(info->udp && ptype.val[3]) {
                    /* Type 3: L4 split if IPv4, UDP */
                    type = 3;
                    split = info->l4_index;
                }
            }
        }

        if(info->ipv4_ipv6) {
            if(info->fragmented || info->ipv4_ipv6_fragmented) {
                if(ptype.val[4]) {
                    /* Type 4: L3 split if fragmented IPv4 or IPv6 */
                    type = 4;
                    split = info->l3_index;
                }
            } else {
                if(info->tcp && ptype.val[5]) {
                    /* Type 5: L4 split if IPv4, IPv6, TCP */
                    type = 5;
                    split = info->l4_index;
                }

                if(info->udp && ptype.val[6]) {
                    /* Type 6: L4 split if IPv4, IPv6, UDP */
                    type = 6;
                    split = info->l4_index;
                }
            }
        }

        if(info->ipv6) {
            if(info->fragmented) {
                if(ptype.val[7]) {
                    /* Type 7: L3 split if fragmented IPv6 */
                    type = 7;
                    split = info->l3_index;
                }
            } else {
                if(info->tcp && ptype.val[8]) {
                    /* Type 8: L4 split if IPv6, TCP */
                    type = 8;
                    split = info->l4_index;
                }

                if(info->udp && ptype.val[9]) {
                    /* Type 9: L4 split if IPv6, UDP */
                    type = 9;
                    split = info->l4_index;
                }
            }
        }

        log info, 4: "ptype: %08x", ptype.val;
        log info, 4: "ipv4: %d, udp: %d, tcp: %d, frag: %d",
            info->ipv4?1:0, info->udp?1:0, info->tcp?1:0, info->fragmented?1:0;
        log info, 4: "packet split at %d (type %d)", split, type;
        return (type, split);
    }

    /* 0 - Legacy
       1 - Advanced, one buffer
       2 - Advanced, header splitting
       3 - Advanced, always header replication
       4 - Advanced, large packet only header replication
       5 - advanced, header splitting, always use header buffer
    */
    method save_packet_one_buffer(const uint8 *frame,
                                  frame_info_t *info) throws {
        local uint16 buf_size;
        local uint8  desc[16];
        local uint64 daddr;
        local uint16 index = 0;
        local uint16 type;
        local uint16 split;

        buf_size = buffer_size();
        while (index < info->length) {
            local uint64 w_addr;
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local adv_rd_rx_desc_t *rrd = cast(desc, void*);
            local adv_wb_rx_desc_t *wrd = cast(desc, void*);

            daddr = load_descriptor(desc, DESC_SIZE);

            local uint64 buf_addr = rrd->buf_addr;

            local uint16 buf_len = 0;

            memset(wrd, 0, 16);

            buf_len = step;

            if(buf_len > 0) {
                log info, 4: "copying %d bytes to main buffer (%llx)",
                    buf_len, buf_addr;
                memory_write(buf_addr, &frame[index], buf_len);
                index += buf_len;
            }

            wrd->desc1.length = buf_len;

            wrd->desc0.rss_info = info->hash;
            wrd->desc0.rss_type = info->rss_type;
            wrd->desc0.l2p = 0;
            wrd->desc0.sph = 0; // always no split

            if(info->ipv4)
                wrd->desc0.packet_type[0] = 1;
            if(info->ipv6)
                wrd->desc0.packet_type[2] = 1;
            if(info->tcp)
                wrd->desc0.packet_type[4] = 1;
            if(info->udp)
                wrd->desc0.packet_type[5] = 1;

            if (info->vp) {
                wrd->desc1.pri  = info->vlan[15:13];
                wrd->desc1.cfi  = info->vlan[12:12];
                wrd->desc1.vlan = info->vlan[11:0];
                wrd->desc1.vp   = 1;
            }
            wrd->desc1.rxe      = 0;
            wrd->desc1.l4e      = 0;
            wrd->desc1.ipe      = 0;
            wrd->desc1.ce       = 0;
            wrd->desc1.udpv     = 0;
            wrd->desc1.vext     = 0;
            wrd->desc1.pif      = info->pif;
            wrd->desc1.ipcs     = 0;
            wrd->desc1.l4i      = 0;
            wrd->desc1.udpcs    = 0;
            wrd->desc1.vp       = info->vp ? 1 : 0;
            wrd->desc1.eop      = (index == info->length) ? 1 : 0;
            wrd->desc1.dd       = 1;

            memory_write(daddr, &desc[0], DESC_SIZE);
            increase_header(DESC_SIZE);
        }
    }

    method save_packet_split_always_use_header(const uint8 *frame,
                                               frame_info_t *info) throws {
        local uint16 buf_size;
        local uint16 header_size;
        local uint8  desc[16];
        local uint64 daddr;
        local uint16 index = 0;
        local uint16 type;
        local uint16 split;

        (type, split) = get_split_type(frame, info);

        buf_size = buffer_size();
        header_size = this.header_size();

        while (index < info->length) {
            local uint64 w_addr;
            local uint16 step = ((info->length - index) > buf_size
                                 ? buf_size : (info->length - index));
            local adv_rd_rx_desc_t *rrd = cast(desc, void*);
            local adv_wb_rx_desc_t *wrd = cast(desc, void*);

            daddr = load_descriptor(desc, DESC_SIZE);

            local uint64 head_addr = rrd->head_addr;
            local uint64 buf_addr = rrd->buf_addr;

            local uint16 head_len = 0;
            local uint16 buf_len = 0;
            local uint1 sph = 0;

            memset(wrd, 0, 16);

            /* Only use header buffer in the first descriptor */
            if(index == 0) {
                if(type == 0) {
                    log info, 4:
                        "no split, storing part of frame in header buffer";
                    head_len = (step > header_size) ? header_size : step;
                } else {
                    head_len = split;
                    sph = 1;
                }
            }

            buf_len = (step > head_len) ? step - head_len : 0;

            if(head_len > 0) {
                log info, 4: "copying %d bytes to header buffer (%llx)",
                    head_len, head_addr;
                memory_write(head_addr, &frame[index], head_len);
                index += head_len;
            }

            if(buf_len > 0) {
                log info, 4: "copying %d bytes to main buffer (%llx)",
                    buf_len, buf_addr;
                memory_write(buf_addr, &frame[index], buf_len);
                index += buf_len;
            }

            wrd->desc0.hdr_len = head_len;
            wrd->desc1.length = buf_len;

            wrd->desc0.rss_info = info->hash;
            wrd->desc0.rss_type = info->rss_type;
            wrd->desc0.l2p = 0;
            wrd->desc0.sph = sph;

            if(info->ipv4)
                wrd->desc0.packet_type[0] = 1;
            if(info->ipv6)
                wrd->desc0.packet_type[2] = 1;
            if(info->tcp)
                wrd->desc0.packet_type[4] = 1;
            if(info->udp)
                wrd->desc0.packet_type[5] = 1;

            if (info->vp) {
                wrd->desc1.pri  = info->vlan[15:13];
                wrd->desc1.cfi  = info->vlan[12:12];
                wrd->desc1.vlan = info->vlan[11:0];
                wrd->desc1.vp   = 1;
            }
            wrd->desc1.rxe      = 0;
            wrd->desc1.l4e      = 0;
            wrd->desc1.ipe      = 0;
            wrd->desc1.ce       = 0;
            wrd->desc1.udpv     = 0;
            wrd->desc1.vext     = 0;
            wrd->desc1.pif      = info->pif;
            wrd->desc1.ipcs     = 0;
            wrd->desc1.l4i      = 0;
            wrd->desc1.udpcs    = 0;
            wrd->desc1.vp       = info->vp ? 1 : 0;
            wrd->desc1.eop      = (index == info->length) ? 1 : 0;
            wrd->desc1.dd       = 1;

            memory_write(daddr, &desc[0], DESC_SIZE);
            increase_header(DESC_SIZE);
        }
    }

    method buffer_size() -> (uint16) {
        local uint16 buf_len;
        if(bsize_pkt.val > 0) {
            buf_len = bsize_pkt.val * 1024;
        } else {
            buf_len = 256 << (3 - bsize.val);
        }
        return buf_len;
    }

    method header_size() -> (uint16) {
        local uint16 header_len;
        if(dtyp.val <= 1) {
            header_len = 0;
        } else {
            header_len = bsize_header.val * 64;
        }
        return header_len;
    }
}

template adv_rx_desc_queue_alias {
    param BA default undefined;
    param reggroup default undefined;
    register srrctl @ BA + 0x0c is (register_alias) {
        param target = reggroup[i].srrctl;
    }
}
