/*
  i210-mac-rx.dml

  Â© 2013 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

dml 1.4;
import "e1000-mac-rx.dml";

param RA_CNT = 16;
param RA_CNT2 = 8;

param MTA_CNT = 128;       // 128regs * 32bits = 4096 bits

bank csr {
    /* --------------------------------------------------------------
       RECEIVE REGISTERS
       -------------------------------------------------------------- */

    register rxpbs   @ 0x02404 "RX Packet buffer size";
    register rlpml   @ 0x05004 "RX long packet max length";

    group rx_queue [i < NUM_RECEIVE_QUEUES] {
        is rx_desc_queue;
        is adv_rx_desc_queue;
        param BA = 0x0c000 + i * 0x40;
        param rdmts  = srrctl.rdmts;
        param dtyp   = srrctl.desctype;
        param bsize  = rctl.bsize;
        param bsize_pkt  = srrctl.bszpkt;
        param bsize_header = srrctl.bszhdr;
        param ptype = psrtype[i];
    }

    group rx_queue_alias [i < NUM_RECEIVE_QUEUES] {
        is rx_desc_queue_alias;
        is adv_rx_desc_queue_alias;
        param BA = 0x02800 + i * 0x100;
        param reggroup = rx_queue;
    }

    register psrtype[i < NUM_RECEIVE_QUEUES] @ 0x5480 + i * 4 "Packet Split Receive Type";

    // This group defines the ral[0..15] and rah[0..15] registers, used to store receive MAC address
    group ra [i <  (RA_CNT)] {
        is rx_mac_register;
        register low  @ 0x05400 + i * 8 "Receive Address Low";
        register high @ 0x05404 + i * 8 "Receive Address High";
    }
    group ra2 [i <  (RA_CNT2)] {
        is rx_mac_register;
        register low  @ 0x054e0 + i * 8 "Receive Address Low";
        register high @ 0x054e4 + i * 8 "Receive Address High";
    }

    register mrqc    @ 0x05818 "Multiple Receive Queues Command";

    event rx_delay is (intr_delay_evt) { param INTR = INTR_RXTO; }

    register rctl {
        is rx_buffer_ctrl;
        // reserved[0]
        field en @ [1] is (write) "Receiver Enable" {
            method write(uint64 value) {
                this.val = value;
                // according to 82576 datasheet, rxdctl que 0 is enabled
                // whenever rctl.en bit is set
                if (value != 0) rx_queue[0].rxdctl.en.val = 1;
                else rx_queue[0].rxdctl.en.val = 0;
            }
        }
        field sbp @ [2] "Store Bad Packets";
        field upe @ [3] "Unicast Promiscuous Enabled";
        field mpe @ [4] "Multicast Promiscuous Enabled";
        field lpe @ [5] "Long Packet Reception Enabled";
        field lbm @ [7:6]  is (unimpl) "Loopback Mode";
        // reserved[11:8]
        // Not in datasheet but e1000 tests require it:
        field reserved_dtyp @ [11:10] is (unimpl) "Receive Descriptor Type";
        field mo @ [13:12] "Multicast Offset";
        // reserved[14]
        field bam @ [15] "Broadcast Accept Mode";
        field vfe @ [18] "VLAN Filter Enable";
        field cfien @ [19] "Canonical Form Indicator Enable";
        field cfi @ [20] "Canonical Form Indicator Bit Value";
        field psp @ [21]   is (unimpl) "Pad Small Receive Packets";
        field dpf @ [22]   is (unimpl) "Discard Pause Frames";
        field pmcf @ [23]  is (unimpl) "Pass MAC Control Frame";
        // reserved[25:24]
        field secrc @ [26] "Strip Ethernet CRC from incoming Packet";
        // reserved[31:27]
    }
    register rxpbs {
        param init_val = 0x40;
    }
    register rlpml is (unimpl);

    register psrtype[i < 4];

    register rxcsum {
        field pcss @ [7:0] "Packet Checksum Start";
        field ipofld @ [8] "IP Checksum Off-load Enable" {
            param init_val = 1;
        }
        field tuofld @ [9] "TCP/UDP Checksum Off-load Enable" {
            param init_val = 1;
        }
        field icmpv6xsum @ [10] is (unimpl) "ICMPv6 Checksum Enable";
        field crcofl @ [11] is (unimpl) "CRC Offload Enable";
        field ippcse @ [12] is (unimpl) "IP Payload Checksum Enable";
        field pcsd @ [13]   is (unimpl) "Packet Checksum Disable";
        // reserved[31:14]
    }

    register rfctl {
        // reserved[5:0]
        field nfsw_dis @ [6] "NFS Write Disable";
        field nfsr_dis @ [7] "NFS Read Disable";
        field nfs_ver @ [9:8] "NFS Version";
        // reserved[10]
        field ipv6xsum_dis @ [11] is (unimpl) "IPv6 Xsum Disable";
        // reserved[13:12]
        field ipfrsp_dis @ [14] "IP Fragment Split Disable";
        // Not in datasheet but e1000 tests require it:
        field reserved_exsten @ [15] is unimpl;
        // reserved[17:15]
        field lef @ [18]        is (unimpl) "Forward Length Error Packet";
        field synqfp @ [19]     is (unimpl) "5-tuple/SYN filter priority";
        // reserved[31:20]
    }

    register reta[i < RETA_CNT] {
        field qidx @ [3:0] "Queue Index";
    }

    register mrqc {
        field mrqe @ [1:0] is (write) "Multiple Receive Queues Enable" {
            method write(uint64 value) {
                if (rctl.en.val == 1) {
                    log spec_viol, 1:
                    "can't modify %s's value when Receiver is enabled", name;
                    return;
                }
                if (this.val != value && value > 1) {
                    log spec_viol, 1: "value %d for %s is reserved, %s",
                        value, name, "adjusted to 0b00";
                    value = 0;
                }
                this.val = value;
            }
        }
        field rssie @ [2] is (unimpl);
        // reserved[15:3]
        field rssfe @ [21:16] "RSS Field Enable";
    }

    method calc_frame_rss_hash(const uint8 *ip, frame_info_t *info) {
        if (mrqc.rssfe.val != 0) {
            if (info->ipv4) {
                if (info->l3_prot == ETH_PROT_TCP && mrqc.rssfe.val[0] != 0)
                    info->rss_type = 1;
                else if (mrqc.rssfe.val[1] != 0)
                    info->rss_type = 2;
            } else if (info->ipv6) {
                if (info->l3_prot == ETH_PROT_TCP && mrqc.rssfe.val[2] != 0)
                    info->rss_type = 3;
                else if (mrqc.rssfe.val[3] != 0 && info->ipv6_ext)
                    info->rss_type = 4;
                else if (mrqc.rssfe.val[4] != 0)
                    info->rss_type = 5;
            }
        }

        if (info->rss_type != 0) {
            info->hash = compute_ip_hash(ip, info->ipv6,
                    info->rss_type == 1 || info->rss_type == 3);
            return;
        }

        info->hash = 0;
        info->rss_type = 0;
        rx_queue_nbr.val = 0;
    }
}

template rx_buffer_ctrl {
    field bsize @ [17:16] "Receive Buffer Size";
}

template flow_ctl_register {
    // reserved[2:0]
    field rt @ [16:4] is (unimpl) "Receive Threshold Value";
    // reserved[30:16]
    field b31 @ [31] is (unimpl) "XON Enable";
}
