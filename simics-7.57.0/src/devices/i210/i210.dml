/*
  © 2013 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

dml 1.4;
device i210;

param desc = "model of Intel® i210 Gb Ethernet controller";
param documentation = "Intel® i210 PCIe Gigabit Ethernet Controller.";

param I210_ETHERNET_LAN = true;
param TCPIP_TX_CONTEXT = false;
param NUM_TRANSMIT_QUEUES = 4;
param NUM_RECEIVE_QUEUES = 4;
param VLAN_PACKET_FILTER = true;
param HAS_EEPROM = true;
param HAS_ACK_ACCELERATION = false;
param HAS_RSS = true;
param HAS_RSS_CPU_SELECTION = false;
param HAS_SMALL_PACKET_DETECTION = false;
param HAS_MTDq1 = true;
param HAS_TIMESYNC = true;
param HAS_EXTENDED_INTERRUPTS = true;
param HAS_L2_ETHTYPE_FILTERS = true;

/* This is wrong, but the Linux drivers still access those registers */
param HAS_INTERRUPT_STATISTICS = true;

// i210 is DML 1.4 but still uses the old PCI library
param e1000_use_legacy_pci_library = true;

import "utility.dml";
import "pci/common.dml";
import "simics/devs/interrupt.dml";

import "i210-mac.dml";
import "i210-pci-common.dml";

param limitations = e1000_limitations
    + "<li>MSI-X is unimplemented.</li>"
    + "<li>Rx replication is not implemented</li>"
    + "<li>Low Latency Interrupt filter and rate limiting is not implemented</li>"
    + "<li>Qav mode is not implemented</li>"
    + "<li>IEEE1588 timestamp is not implemented in L2 EthType filter</li>"
    + "</ul>";

connect flash {
    param documentation = "Connection to the SPI interface in the i210";
    param configuration = "required";
}

attribute flash_func is int64_attr {
    param documentation = "Function number of GbE SPI flash program register bank in the SPI";
    param configuration = "required";
}

is pcie_device;

bank pci_config {
    param base_address_registers = ["membar", "flashbar", "iobar"];

    /* --------------------------------------------------------------
       BASE PCI CONFIGURATION SPACE REGISTERS
       -------------------------------------------------------------- */

    register vendor_id  { param init_val = 0x8086; }
    register device_id { param init_val = 0x1533; }

    register revision_id { param init_val = 0x00; }
    register class_code { param init_val = 0x020000; }

    register header_type {
        field type { param init_val = 0; }
        field mf { param init_val = 1; }
    }

    register membar @ 0x10 is (memory_base_address_32) {
        param desc = "Memory BAR Base Address";
        param size_bits = 17;
        param map_func = 0; // internal csr bank
    }

    register flashbar @ 0x14 is (memory_base_address_32) {
        param desc = "Memory Base Address B";
        param size_bits = 12;
        param map_func = 0;

        method remove_map() {
            local int    succ;

            succ = pci_bus.pci_bus.remove_map(flash.obj, Sim_Addr_Space_Memory, flash_func.val);
            log info, 2, PCI_config: "%s to remove memory mapping for bank %s of SPI flash %s",
                (succ == 1) ? "succeeded" : "failed", flash.port, SIM_object_name(flash.obj);
        }

        method add_map() {
            local int        succ;
            local map_info_t info;

            memset(&info, 0, sizeoftype(map_info_t));
            info.function = flash_func.val;
            info.base = pci_mapping_base();
            info.length = pci_mapping_length();
            succ = pci_bus.pci_bus.add_map(flash.obj, Sim_Addr_Space_Memory, NULL, info);
            log info, 2, PCI_config: "%s to map bank %s of SPI flash %s to memory space at 0x%x",
                (succ == 1) ? "succeeded" : "failed", flash.port, SIM_object_name(flash.obj), info.base;
        }
    }

    register iobar @ 0x18 is (io_base_address) {
        param desc = "IO BAR Base Address";
        param size_bits = 5;
        param map_func = 1; //io-window
    }

    register base_address_3 @ 0x1C is (no_base_address_32);
    register base_address_4 @ 0x20 is (no_base_address_32);
    register base_address_5 @ 0x24 is (no_base_address_32);

    register cardbus_cis_ptr;
    register subsystem_vendor_id { param init_val = 0x8086; }
    register subsystem_id { param init_val = 0x0000; }
    register interrupt_pin { param init_val = 0x01; }

    // Assumed no Flash memory. If a Flash memory is attached, this register might have to change.
    // Updated through EEPROM
    // register expansion_rom_base;

    register capabilities_ptr { param init_val = 0x40; }

    /* --------------------------------------------------------------
       PCI POWER MANAGEMENT REGISTERS (CAPABILITY)
       -------------------------------------------------------------- */

    is defining_pci_pm_capability;
    param pm_offset     = 0x40;
    param pm_next_ptr   = 0x50;

    register pm_capabilities {
        field dsi { param init_val = 0b1; }
    }
    // When EEPROM support is added, the pm_status_control.data_scale field might be loaded from EEPROM
    // When EEPROM support is added, the pm_data register might be loaded from EEPROM

    /* --------------------------------------------------------------
       MESSAGE SIGNALED INTERRUPT (MSI) CONFIGURATION REGISTERS (CAPABILITY)
       -------------------------------------------------------------- */

    is defining_pci_msi64_capability;
    param msi_offset    = 0x50;
    param msi_next_ptr  = 0x70;

    /* --------------------------------------------------------------
       PCIE CONFIGURATION REGISTERS (CAPABILITY)
       -------------------------------------------------------------- */
    is defining_i210_pci_express_capability;
    param exp_offset = 0xa0;
    param exp_next_ptr = 0x0;

    /* --------------------------------------------------------------
       PCIE EXTENDED CONFIGURATION SPACE
       ADVANCED ERROR REPORTING CAPABILITY
       -------------------------------------------------------------- */
    is defining_pcie_aer_capability_v2;
    param aer_offset = 0x100;
    param aer_next_ptr = 0x140; // Not a documented value

    /* --------------------------------------------------------------
       DEVICE SERIAL NUMBER CAPABILITY
       -------------------------------------------------------------- */
    is defining_pcie_dsn_capability_v1;
    param dsn_offset = 0x140;   // Not a documented value
    param dsn_next_ptr = 0x0;
    // dsn_serial_number (low and high) are based on the MAC address and are loaded from EEPROM

    is soft_reset;
    method soft_reset() {
        // PCI config space is not affected by software reset
    }
}

method init() {
    tx_init();
}
